// scripts/energyplusModelBuilder.js
// Minimal EnergyPlus IDF builder integrated with Ray-Modeler data structures.
// Goal: take current project state and global simulation params and emit a runnable IDF
// and provide a diagnostics summary for UI visibility.
//
// Canonical configuration entrypoint (single source of truth):
//   meta.energyPlusConfig (or meta.energyplus for backward-compat)
//
// energyPlusConfig schema (summary):
//
//   {
//     timestep?: number,
//     runPeriod?: { startMonth, startDay, endMonth, endDay },
//     northAxis?: number,
//     terrain?: string,
//     weatherFilePath?: string,
//     location?: {
//       name: string,
//       latitude: number,
//       longitude: number,
//       timeZone: number,
//       elevation: number,
//     },
//
//     materials?: ( ... ),
//     constructions?: ( ... ),
//     schedules?: { ... },
//     defaults?: { ... },
//     zoneLoads?: ( ... ),
//     thermostats?: ( ... ),
//     idealLoads?: ( ... ),
//     daylighting?: ( ... )
//   }
//
// Notes:
// - All names are sanitized by sanitize().
// - Builder/diagnostics are pure/deterministic: no DOM, no side effects beyond return values.
// - Invalid or incomplete entries are gracefully ignored; built-ins provide robustness.

import { project } from './project.js';
import * as energyplusDefaults from './energyplusDefaults.js';

/**
 * Build a minimal EnergyPlus IDF from the current Ray-Modeler project.
 */
export function buildEnergyPlusModel(options = {}) {
    const {
        weatherFilePath,
        weather,
        buildingName,
        runPeriod,
        timestep,
        northAxis,
        terrain,
        location,
        materials,
        constructions,
        schedules,
        loads,
        defaults,
        idealLoads,
        thermostats,
        daylighting,
    } = options;

    // Normalize unified weather/location config
    const weatherCfg = weather || {};
    const epwPath = weatherFilePath || weatherCfg.epwPath;
    const locationSource = weatherCfg.locationSource || 'FromEPW';
    const customLocation = weatherCfg.customLocation;

    const idf = [];
    const epDefaults = energyplusDefaults.loadDefaults();

    idf.push(`! ==============================================================================`);
    idf.push(`!  IDF generated by Ray-Modeler (EnergyPlus integration)`);
    idf.push(`!  This is a minimal auto-generated model; extend mappings as needed.`);
    idf.push(`! ==============================================================================`);
    idf.push('');

    // VERSION
    idf.push(`Version,`);
    idf.push(`  25.1;                      !- Version Identifier`);
    idf.push('');

    // TIMESTEP
    let ts = Number.isFinite(timestep) && timestep > 0 ? timestep : null;
    if (!ts && epDefaults?.simulation?.Timestep?.NumberOfTimestepsPerHour) {
        ts = epDefaults.simulation.Timestep.NumberOfTimestepsPerHour;
    }
    if (!ts) ts = 6;
    idf.push(`Timestep,`);
    idf.push(`  ${ts};                     !- Number of Timesteps per Hour`);
    idf.push('');

    // SIMULATIONCONTROL
    if (epDefaults?.simulation?.['SimulationControl']) {
        const sc = epDefaults.simulation['SimulationControl'];
        idf.push(`SimulationControl,`);
        idf.push(`  ${sc.DoZoneSizingCalculation || 'No'},  !- Do Zone Sizing Calculation`);
        idf.push(`  ${sc.DoSystemSizingCalculation || 'No'},  !- Do System Sizing Calculation`);
        idf.push(`  ${sc.DoPlantSizingCalculation || 'No'},  !- Do Plant Sizing Calculation`);
        idf.push(`  ${sc.RunSimulationForSizingPeriods || 'No'},  !- Run Simulation for Sizing Periods`);
        idf.push(`  ${sc.RunSimulationForWeatherFileRunPeriods || 'Yes'};  !- Run Simulation for Weather File Run Periods`);
        idf.push('');
    } else {
        idf.push(`SimulationControl,`);
        idf.push(`  Yes,                      !- Do Zone Sizing Calculation`);
        idf.push(`  Yes,                      !- Do System Sizing Calculation`);
        idf.push(`  Yes,                      !- Do Plant Sizing Calculation`);
        idf.push(`  No,                       !- Run Simulation for Sizing Periods`);
        idf.push(`  Yes;                      !- Run Simulation for Weather File Run Periods`);
        idf.push('');
    }

    // SITE:LOCATION
    // Strategy:
    // - If weather.locationSource === 'Custom' and customLocation is valid, use it.
    // - Else if options.location is provided (legacy hook), use it.
    // - Else try to infer from project.
    // - Fallback to Athens-GR.
    let loc = null;
    if (
        locationSource === 'Custom' &&
        customLocation &&
        isValidCustomLocation(customLocation)
    ) {
        loc = customLocation;
    } else if (location) {
        loc = location;
    } else {
        loc = inferLocationFromProject();
    }
    if (!loc) {
        loc = {
            name: 'Athens-GR',
            latitude: 37.98,
            longitude: 23.72,
            timeZone: 2.0,
            elevation: 107.0,
        };
    }

    idf.push(`Site:Location,`);
    idf.push(`  ${sanitize(loc.name)},     !- Name`);
    idf.push(`  ${loc.latitude},           !- Latitude {deg}`);
    idf.push(`  ${loc.longitude},          !- Longitude {deg}`);
    idf.push(`  ${loc.timeZone},           !- Time Zone {hr}`);
    idf.push(`  ${loc.elevation};          !- Elevation {m}`);
    idf.push('');

    // RUNPERIOD (legacy simple)
    const rp = runPeriod || {
        startMonth: 1,
        startDay: 1,
        endMonth: 12,
        endDay: 31,
    };

    idf.push(`RunPeriod,`);
    idf.push(`  Annual,                   !- Name`);
    idf.push(`  ${rp.startMonth},         !- Begin Month`);
    idf.push(`  ${rp.startDay},           !- Begin Day of Month`);
    idf.push(`  ,                         !- Begin Year`);
    idf.push(`  ${rp.endMonth},           !- End Month`);
    idf.push(`  ${rp.endDay},             !- End Day of Month`);
    idf.push(`  ,                         !- End Year`);
    idf.push(`  UseWeatherFile,           !- Day of Week for Start Day`);
    idf.push(`  Yes,                      !- Use Weather File Holidays and Special Days`);
    idf.push(`  Yes,                      !- Use Weather File Daylight Saving Period`);
    idf.push(`  Yes,                      !- Apply Weekend Holiday Rule`);
    idf.push(`  Yes,                      !- Use Weather File Rain Indicators`);
    idf.push(`  Yes;                      !- Use Weather File Snow Indicators`);
    idf.push('');

    // BUILDING (from defaults or overrides)
    const defaultBuilding = epDefaults?.simulation?.Building || {};
    const bName = buildingName || inferBuildingNameFromProject() || defaultBuilding.Name || 'Ray-Modeler Building';
    const bNorthAxis = Number.isFinite(northAxis)
        ? northAxis
        : (typeof defaultBuilding.NorthAxis_deg === 'number' ? defaultBuilding.NorthAxis_deg : 0.0);
    const bTerrain = terrain || defaultBuilding.Terrain || 'City';
    const bLoadsTol = defaultBuilding.LoadsConvergenceTolerance ?? 0.04;
    const bTempTol = defaultBuilding.TemperatureConvergenceTolerance_deltaC ?? 0.4;
    const bSolar = defaultBuilding.SolarDistribution || 'FullExterior';
    const bMaxWU = defaultBuilding.MaximumNumberOfWarmupDays ?? 25;
    const bMinWU = defaultBuilding.MinimumNumberOfWarmupDays ?? 6;

    idf.push(`Building,`);
    idf.push(`  ${sanitize(bName)},        !- Name`);
    idf.push(`  ${bNorthAxis},            !- North Axis {deg}`);
    idf.push(`  ${bTerrain},              !- Terrain`);
    idf.push(`  ${bLoadsTol},             !- Loads Convergence Tolerance Value`);
    idf.push(`  ${bTempTol},              !- Temperature Convergence Tolerance Value {deltaC}`);
    idf.push(`  ${bSolar},                !- Solar Distribution`);
    idf.push(`  ${bMaxWU},                !- Maximum Number of Warmup Days`);
    idf.push(`  ${bMinWU};                !- Minimum Number of Warmup Days`);
    idf.push('');

    // 2) Materials and Constructions
    const materialLibrary = buildMaterialLibrary(materials, epDefaults);
    emitMaterials(idf, materialLibrary);

    const constructionLibrary = buildConstructionLibrary(constructions, materialLibrary);
    emitConstructions(idf, constructionLibrary);

    // defaultConstructions reserved for future explicit surface mapping
    const defaultConstructions = {
        wall: defaults?.wallConstruction || 'RM_Ext_Wall',
        roof: defaults?.roofConstruction || 'RM_Roof',
        floor: defaults?.floorConstruction || 'RM_Slab_On_Grade',
        window: defaults?.windowConstruction || 'RM_Dbl_Clr_3mm_13mmAir',
    };
    void defaultConstructions;

    // 3) Schedules
    const scheduleContext = buildSchedules(schedules);
    emitSchedules(idf, scheduleContext);

    // 4) Zones (from project; simple)
    const zones = inferZonesFromProject();
    if (!zones.length) {
        idf.push(`Zone,`);
        idf.push(`  Zone_1,                   !- Name`);
        idf.push(`  0.0,                      !- Direction of Relative North {deg}`);
        idf.push(`  0.0, 0.0, 0.0,            !- X,Y,Z Origin {m}`);
        idf.push(`  1,                        !- Type`);
        idf.push(`  1,                        !- Multiplier`);
        idf.push(`  autocalculate,            !- Ceiling Height {m}`);
        idf.push(`  autocalculate;            !- Volume {m3}`);
        idf.push('');
    } else {
        zones.forEach((z) => {
            idf.push(`Zone,`);
            idf.push(`  ${sanitize(z.name)},      !- Name`);
            idf.push(`  0.0,                      !- Direction of Relative North {deg}`);
            idf.push(`  ${z.x || 0.0}, ${z.y || 0.0}, ${z.z || 0.0},  !- X,Y,Z Origin {m}`);
            idf.push(`  1,                        !- Type`);
            idf.push(`  ${z.multiplier || 1},      !- Multiplier`);
            idf.push(`  autocalculate,            !- Ceiling Height {m}`);
            idf.push(`  autocalculate;            !- Volume {m3}`);
            idf.push('');
        });
    }

    // 5) Internal loads
    emitZoneLoads(idf, zones, loads, scheduleContext);

    // 6) Outdoor Air Design Specifications (must come before Sizing so links resolve)
    // Opt-in: only emit when at least one DesignSpecification entry is valid.
    if (options.outdoorAir && Array.isArray(options.outdoorAir.designSpecs) && options.outdoorAir.designSpecs.length) {
        emitDesignSpecificationOutdoorAir(idf, options.outdoorAir, scheduleContext);
        emitDesignSpecificationOutdoorAirSpaceList(idf, options.outdoorAir);
    }

    // 7) Sizing Objects
    // Opt-in: only emit advanced Sizing:System/Plant when user provided them.
    const sizingCfg = options.sizing || {};
    emitSizingZone(idf, zones, sizingCfg);
    if (Array.isArray(sizingCfg.systems) && sizingCfg.systems.length) {
        emitSizingSystem(idf, sizingCfg);
    }
    if (Array.isArray(sizingCfg.plants) && sizingCfg.plants.length) {
        emitSizingPlant(idf, sizingCfg);
    }

    // 8) Thermostats & IdealLoads
    // Always safe: IdealLoads/thermostats helper is internally defensive.
    emitThermostatsAndIdealLoads(idf, zones, scheduleContext, idealLoads, thermostats);

    // 9) Daylighting & Outputs (opt-in)
    if (daylighting && (daylighting.zones || (daylighting.outputs && (daylighting.outputs.illuminanceMaps || daylighting.outputs.variables)))) {
        emitDaylighting(idf, zones, daylighting);
    }

    // 10) Natural Ventilation (ZoneVentilation:DesignFlowRate, opt-in)
    if (options.naturalVentilation && (options.naturalVentilation.global || (Array.isArray(options.naturalVentilation.perZone) && options.naturalVentilation.perZone.length))) {
        emitZoneVentilation(idf, zones, options.naturalVentilation, scheduleContext);
    }

    // 11) Shading & Solar Control (opt-in)
    //
    // Canonical schema (single source of truth for shading configuration):
    //   options.shading = {
    //     siteSurfaces?: Array<{
    //       name: string,
    //       // 'Site' → Shading:Site:Detailed, 'Building' → Shading:Building:Detailed
    //       type?: 'Site' | 'Building',
    //       transmittanceScheduleName?: string,
    //       vertices: Array<{ x: number, y: number, z: number }>
    //     }>,
    //     zoneSurfaces?: Array<{
    //       name: string,
    //       baseSurfaceName: string,
    //       transmittanceScheduleName?: string,
    //       vertices: Array<{ x: number, y: number, z: number }>
    //     }>,
    //     reflectance?: Array<{
    //       shadingSurfaceName: string,
    //       solarReflectance?: number,
    //       visibleReflectance?: number,
    //       infraredHemisphericalEmissivity?: number,
    //       infraredTransmittance?: number
    //     }>,
    //     windowShadingControls?: Array<{
    //       name: string,
    //       shadingType: string,
    //       controlType: string,
    //       scheduleName?: string,
    //       setpoint1?: number,
    //       setpoint2?: number,
    //       glareControlIsActive?: boolean,
    //       multipleSurfaceControlType?: string,
    //       fenestrationSurfaceNames: string[]
    //     }>
    //   }
    //
    // This schema is edited by the "Shading & Solar Control" panel via energyplusConfigService.setShading.
    // Legacy hint-style fields (surfaces/windowControls/overhangs) are intentionally ignored here.
    if (options.shading) {
        const hasSite = Array.isArray(options.shading.siteSurfaces) && options.shading.siteSurfaces.length;
        const hasZone = Array.isArray(options.shading.zoneSurfaces) && options.shading.zoneSurfaces.length;
        const hasRefl = Array.isArray(options.shading.reflectance) && options.shading.reflectance.length;
        const hasCtrls = Array.isArray(options.shading.windowShadingControls) && options.shading.windowShadingControls.length;
        if (hasSite || hasZone) {
            emitShadingSurfaces(idf, options.shading, scheduleContext);
        }
        if (hasRefl) {
            emitShadingReflectance(idf, options.shading);
        }
        if (hasCtrls) {
            emitWindowShadingControls(idf, options.shading, scheduleContext);
        }
    }

    // 12) Weather file reference (comment)
    if (epwPath) {
        idf.push(`! Weather file: ${epwPath}`);
        idf.push('');
    }

    return idf.join('\n');
}

/**
 * Build a diagnostics summary describing how options + project geometry map into EnergyPlus objects.
 *
 * @param {object} options Same shape as buildEnergyPlusModel
 * @returns {{
 *   geometry: {
 *     zones: Array<{
 *       name: string,
 *       surfaces: { total: number, exteriorWalls: number, roofs: number, floors: number },
 *       windows: { total: number, totalArea: number },
 *       wwrByOrientation: { N?: number, E?: number, S?: number, W?: number }
 *     }>,
 *     totals: { zones: number, exteriorWalls: number, roofs: number, floors: number, windows: number }
 *   },
 *   constructions: { usedConstructions: Array<{name:string,missing:boolean}>, missingConstructions: string[], unusedConstructions: string[] },
 *   materials: { missingMaterials: string[], unusedMaterials: string[] },
 *   schedulesAndLoads: { missingSchedules: string[], inconsistentLoads: Array<{ zone: string, issue: string }> },
 *   issues: Array<{ severity: 'info'|'warning'|'error', message: string }>
 * }}
 */
export function buildEnergyPlusDiagnostics(options = {}) {
    const {
        weatherFilePath,
        weather,
        materials,
        constructions,
        schedules,
        defaults,
        loads,
        idealLoads,
        thermostats,
        daylighting,
    } = options;

    const issues = [];

    const weatherCfg = weather || {};
    const epwPath = weatherFilePath || weatherCfg.epwPath;
    const locationSource = weatherCfg.locationSource || 'FromEPW';
    const customLocation = weatherCfg.customLocation;

    const epDefaults = energyplusDefaults.loadDefaults();
    const materialLib = buildMaterialLibrary(materials, epDefaults);
    const constructionLib = buildConstructionLibrary(constructions, materialLib);
    const scheduleCtx = buildSchedules(schedules);

    // Geometry snapshot from current parametric model (single room) or fallback.
    const geom = getGeometrySnapshotSafe(issues);
    const znList = geom.zones.length ? geom.zones : inferZonesFromProject();
    const zoneNames = znList.length
        ? znList.map((z, i) => sanitize(z.name || `Zone_${i + 1}`))
        : ['Zone_1'];

    // 1) Geometry diagnostics: per-zone surfaces, windows, WWR
    const geomDiag = computeGeometryDiagnostics(geom, zoneNames);

    // 2) Constructions diagnostics (defaults-based + geometry-based)
    const {
        constructionsDiagnostics,
        missingConstructionsFromDefaults,
    } = computeConstructionsDiagnostics(defaults, constructionLib);

    constructionsDiagnostics.missingConstructions.forEach((name) => {
        if (missingConstructionsFromDefaults.has(name)) {
            issues.push({
                severity: 'error',
                message: `Default construction "${name}" is not defined in EnergyPlus constructions.`,
            });
        }
    });

    // 3) Materials diagnostics (based on constructions)
    const materialsDiagnostics = computeMaterialsDiagnostics(constructionLib, materialLib, issues);

    // 4) Schedules & loads diagnostics
    const schedulesAndLoadsDiagnostics = computeSchedulesAndLoadsDiagnostics(
        scheduleCtx,
        loads,
        idealLoads,
        thermostats,
        daylighting,
        issues
    );

    if (!zoneNames.length) {
        issues.push({
            severity: 'warning',
            message: 'No zones detected; a fallback Zone_1 will be created in the generated IDF.',
        });
    }

    // Weather / location diagnostics
    if (!epwPath && locationSource !== 'Custom') {
        issues.push({
            severity: 'error',
            message:
                'No EPW weather file is configured. Set energyPlusConfig.weather.epwPath in the Weather & Location panel.',
        });
    }

    if (locationSource === 'Custom') {
        if (!customLocation || !isValidCustomLocation(customLocation)) {
            issues.push({
                severity: 'warning',
                message:
                    'Custom location is selected but incomplete or invalid. The generated IDF will fall back to a default location.',
            });
        }
    }

    // Extended diagnostics
    computeSizingDiagnostics(options.sizing || {}, zoneNames, options.outdoorAir || {}, issues);
    computeOutdoorAirDiagnostics(options.outdoorAir || {}, scheduleCtx, issues);
    computeNaturalVentilationDiagnostics(options.naturalVentilation || {}, scheduleCtx, zoneNames, issues);
    computeDaylightingDiagnostics(daylighting, zoneNames, scheduleCtx, issues);
    computeShadingDiagnostics(options.shading || {}, scheduleCtx, issues);

    const diagnostics = {
        geometry: geomDiag,
        constructions: constructionsDiagnostics,
        materials: materialsDiagnostics,
        schedulesAndLoads: schedulesAndLoadsDiagnostics,
        issues,
        weather: {
            epwPath: epwPath || null,
            locationSource,
            customLocation: isValidCustomLocation(customLocation)
                ? customLocation
                : null,
        },
    };

    return diagnostics;
}

/**
 * Extended diagnostics helpers
 */

/**
 * Sizing diagnostics: Sizing:Zone / Sizing:System / Sizing:Plant
 */
function computeSizingDiagnostics(sizingCfg = {}, zoneNames = [], outdoorAir = {}, issues) {
    const znSet = new Set(zoneNames);
    const dsoaNames = new Set(
        (Array.isArray(outdoorAir.designSpecs) ? outdoorAir.designSpecs : [])
            .filter((s) => s && s.name)
            .map((s) => sanitize(s.name))
    );

    // Sizing:Zone
    const szZones = Array.isArray(sizingCfg.zones) ? sizingCfg.zones : [];
    const seenZones = new Set();
    szZones.forEach((z) => {
        if (!z || !z.zoneName) return;
        const zn = sanitize(z.zoneName);
        seenZones.add(zn);
        if (!znSet.has(zn)) {
            issues.push({
                severity: 'warning',
                message: `Sizing.zones entry references unknown zone "${z.zoneName}".`,
            });
        }
        if (z.designSpecOutdoorAirName) {
            const dName = sanitize(z.designSpecOutdoorAirName);
            if (!dsoaNames.has(dName)) {
                issues.push({
                    severity: 'error',
                    message: `Sizing:Zone for "${z.zoneName}" references DesignSpecification:OutdoorAir "${z.designSpecOutdoorAirName}" which is not defined.`,
                });
            }
        }
    });

    if (szZones.length && znSet.size) {
        znSet.forEach((zn) => {
            if (!seenZones.has(zn)) {
                issues.push({
                    severity: 'warning',
                    message: `Sizing.zones is configured but no Sizing:Zone entry provided for zone "${zn}". Defaults will be used.`,
                });
            }
        });
    }

    // Sizing:System
    const systems = Array.isArray(sizingCfg.systems) ? sizingCfg.systems : [];
    systems.forEach((s) => {
        if (!s) return;
        if (!s.airLoopName) {
            issues.push({
                severity: 'warning',
                message: 'Sizing.systems entry is missing "airLoopName".',
            });
        }
        const method = s.systemOutdoorAirMethod || s.systemOutdoorAirMethodEnum;
        if (method && /VRP|IAQP/i.test(String(method))) {
            if (!outdoorAir.designSpecs || !outdoorAir.designSpecs.length) {
                issues.push({
                    severity: 'warning',
                    message: `Sizing:System "${s.airLoopName || '(unnamed)'}" uses "${method}" but no outdoor air design specs are configured.`,
                });
            }
        }
    });

    // Sizing:Plant
    const plants = Array.isArray(sizingCfg.plants) ? sizingCfg.plants : [];
    plants.forEach((p) => {
        if (!p) return;
        if (!p.plantLoopName) {
            issues.push({
                severity: 'warning',
                message: 'Sizing.plants entry is missing "plantLoopName".',
            });
        }
        const hasExit = p.designLoopExitTemperature != null;
        const hasDT = p.loopDesignTemperatureDifference != null;
        if ((hasExit && !hasDT) || (!hasExit && hasDT)) {
            issues.push({
                severity: 'warning',
                message: `Sizing:Plant "${p.plantLoopName || '(unnamed)'}" has incomplete sizing data (both exit temperature and delta T should be set).`,
            });
        }
    });
}

/**
 * Outdoor air diagnostics for DesignSpecification:OutdoorAir / SpaceList
 */
function computeOutdoorAirDiagnostics(outdoorAir = {}, scheduleCtx, issues) {
    const compact = scheduleCtx.compact || {};
    const hasSchedule = (name) => !!(name && compact[sanitize(name)]);

    const specs = Array.isArray(outdoorAir.designSpecs)
        ? outdoorAir.designSpecs
        : [];
    const specNames = new Set();

    specs.forEach((s) => {
        if (!s || !s.name) return;
        const name = sanitize(s.name);
        specNames.add(name);

        const method = s.method || 'Flow/Person';
        const hasAnyFlow =
            s.flowPerPerson != null ||
            s.flowPerArea != null ||
            s.flowPerZone != null ||
            s.airChangesPerHour != null;

        if (!hasAnyFlow) {
            issues.push({
                severity: 'warning',
                message: `DesignSpecification:OutdoorAir "${s.name}" uses method "${method}" but has no flow values defined.`,
            });
        }

        if (s.scheduleName && !hasSchedule(s.scheduleName)) {
            issues.push({
                severity: 'warning',
                message: `DesignSpecification:OutdoorAir "${s.name}" references missing schedule "${s.scheduleName}".`,
            });
        }
        if (s.proportionalMinOAFractionScheduleName && !hasSchedule(s.proportionalMinOAFractionScheduleName)) {
            issues.push({
                severity: 'warning',
                message: `DesignSpecification:OutdoorAir "${s.name}" references missing proportional minimum OA schedule "${s.proportionalMinOAFractionScheduleName}".`,
            });
        }
    });

    const lists = Array.isArray(outdoorAir.spaceLists)
        ? outdoorAir.spaceLists
        : [];
    lists.forEach((sl) => {
        if (!sl || !sl.name || !Array.isArray(sl.items)) return;
        sl.items.forEach((it) => {
            if (!it || !it.spaceName || !it.designSpecOutdoorAirObjectName) return;
            const dName = sanitize(it.designSpecOutdoorAirObjectName);
            if (!specNames.has(dName)) {
                issues.push({
                    severity: 'error',
                    message: `DesignSpecification:OutdoorAir:SpaceList "${sl.name}" references unknown DesignSpecification:OutdoorAir "${it.designSpecOutdoorAirObjectName}".`,
                });
            }
        });
    });
}

/**
 * Natural ventilation diagnostics (ZoneVentilation:DesignFlowRate)
 */
function computeNaturalVentilationDiagnostics(natVentCfg = {}, scheduleCtx, zoneNames, issues) {
    const compact = scheduleCtx.compact || {};
    const hasSchedule = (name) => !!(name && compact[sanitize(name)]);

    const znSet = new Set(zoneNames);
    const globalCfg = natVentCfg.global || {};
    const perZone = Array.isArray(natVentCfg.perZone) ? natVentCfg.perZone : [];

    const checkCfg = (label, cfg) => {
        if (!cfg) return;

        const flowsDefined =
            cfg.designFlowRate != null ||
            cfg.flowPerArea != null ||
            cfg.flowPerPerson != null ||
            cfg.airChangesPerHour != null;

        if (cfg.enabled && !flowsDefined) {
            issues.push({
                severity: 'warning',
                message: `Natural ventilation for ${label} is enabled but has no effective flow defined.`,
            });
        }

        const scheds = [
            cfg.scheduleName,
            cfg.minIndoorTempScheduleName,
            cfg.maxIndoorTempScheduleName,
            cfg.deltaTempScheduleName,
            cfg.minOutdoorTempScheduleName,
            cfg.maxOutdoorTempScheduleName,
        ];
        scheds.forEach((sn) => {
            if (sn && !hasSchedule(sn)) {
                issues.push({
                    severity: 'warning',
                    message: `Natural ventilation for ${label} references missing schedule "${sn}".`,
                });
            }
        });
    };

    if (globalCfg) {
        checkCfg('global', globalCfg);
    }

    perZone.forEach((pz) => {
        if (!pz || !pz.zoneName) return;
        const zn = sanitize(pz.zoneName);
        if (!znSet.has(zn)) {
            issues.push({
                severity: 'warning',
                message: `Natural ventilation perZone entry references unknown zone "${pz.zoneName}".`,
            });
        }
        checkCfg(`zone "${pz.zoneName}"`, pz);
    });
}

/**
 * Daylighting diagnostics
 */
function computeDaylightingDiagnostics(daylighting, zoneNames, scheduleCtx, issues) {
    if (!daylighting) return;

    const znSet = new Set(zoneNames);
    const compact = scheduleCtx.compact || {};
    const hasSchedule = (name) => !!(name && compact[sanitize(name)]);

    // Advanced zones[]
    const zonesCfg = Array.isArray(daylighting.zones) ? daylighting.zones : [];
    zonesCfg.forEach((cfg) => {
        if (!cfg || !cfg.zoneName) return;
        const zn = sanitize(cfg.zoneName);
        if (!znSet.has(zn)) {
            issues.push({
                severity: 'warning',
                message: `Daylighting.zones entry references unknown zone "${cfg.zoneName}".`,
                context: { domain: 'daylighting', type: 'zone', zoneName: cfg.zoneName },
            });
        }

        if (cfg.enabled === false) return;

        const refs = Array.isArray(cfg.referencePoints)
            ? cfg.referencePoints.filter(
                  (rp) =>
                      rp &&
                      Number.isFinite(rp.x) &&
                      Number.isFinite(rp.y) &&
                      Number.isFinite(rp.z)
              )
            : [];
        if (!refs.length) {
            issues.push({
                severity: 'warning',
                message: `Daylighting for zone "${cfg.zoneName}" has no valid reference points configured.`,
                context: { domain: 'daylighting', type: 'zone', zoneName: cfg.zoneName },
            });
        }

        if (cfg.availabilityScheduleName && !hasSchedule(cfg.availabilityScheduleName)) {
            issues.push({
                severity: 'warning',
                message: `Daylighting for zone "${cfg.zoneName}" references missing availability schedule "${cfg.availabilityScheduleName}".`,
            });
        }

        if (Array.isArray(cfg.fractions) && cfg.fractions.length >= 2) {
            const sum = cfg.fractions
                .slice(0, 2)
                .reduce((a, b) => a + (typeof b === 'number' ? b : 0), 0);
            if (sum <= 0 || sum > 1.01) {
                issues.push({
                    severity: 'warning',
                    message: `Daylighting fractions for zone "${cfg.zoneName}" look inconsistent (sum=${sum.toFixed(
                        3
                    )}).`,
                    context: { domain: 'daylighting', type: 'zone', zoneName: cfg.zoneName },
                });
            }
        }
    });

    // Legacy controls[]
    const legacy = Array.isArray(daylighting.controls)
        ? daylighting.controls
        : [];
    legacy.forEach((c) => {
        if (!c || !c.zoneName) return;
        const zn = sanitize(c.zoneName);
        if (!znSet.has(zn)) {
            issues.push({
                severity: 'warning',
                message: `Legacy daylighting.controls entry references unknown zone "${c.zoneName}".`,
                context: { domain: 'daylighting', type: 'legacyControl', zoneName: c.zoneName },
            });
        }
        const refs = Array.isArray(c.refPoints)
            ? c.refPoints.filter(
                  (rp) =>
                      rp &&
                      Number.isFinite(rp.x) &&
                      Number.isFinite(rp.y) &&
                      Number.isFinite(rp.z)
              )
            : [];
        if (!refs.length || !Number.isFinite(c.setpoint)) {
            issues.push({
                severity: 'warning',
                message: `Legacy daylighting control for zone "${c.zoneName}" is incomplete (missing refPoints or setpoint).`,
                context: { domain: 'daylighting', type: 'legacyControl', zoneName: c.zoneName },
            });
        }
    });

    // Illuminance maps
    const outputs = daylighting.outputs || {};
    const maps = []
        .concat(
            Array.isArray(outputs.illuminanceMaps)
                ? outputs.illuminanceMaps
                : []
        )
        .concat(
            (Array.isArray(daylighting.zones)
                ? daylighting.zones
                : []
            ).flatMap((z) =>
                Array.isArray(z.illuminanceMaps)
                    ? z.illuminanceMaps.map((m) => ({
                          ...m,
                          zoneName: z.zoneName,
                      }))
                    : []
            )
        );

    maps.forEach((m) => {
        if (!m || !m.zoneName) return;
        const zn = sanitize(m.zoneName);
        if (!znSet.has(zn)) {
            issues.push({
                severity: 'warning',
                message: `Illuminance map "${m.name || '(unnamed)'}" references unknown zone "${m.zoneName}".`,
                context: {
                    domain: 'daylighting',
                    type: 'illuminanceMap',
                    mapName: m.name || '(unnamed)',
                    zoneName: m.zoneName,
                },
            });
        }
        const requiredNums = [
            m.xOrigin,
            m.yOrigin,
            m.zHeight,
            m.xNumPoints,
            m.xSpacing,
            m.yNumPoints,
            m.ySpacing,
        ];
        if (requiredNums.some((v) => !Number.isFinite(v))) {
            issues.push({
                severity: 'warning',
                message: `Illuminance map "${m.name || '(unnamed)'}" for zone "${m.zoneName}" has invalid or missing numeric fields.`,
                context: {
                    domain: 'daylighting',
                    type: 'illuminanceMap',
                    mapName: m.name || '(unnamed)',
                    zoneName: m.zoneName,
                },
            });
        }
    });
}

/**
 * Shading diagnostics
 */
function computeShadingDiagnostics(shading = {}, scheduleCtx, issues) {
    if (!shading) return;

    const compact = scheduleCtx.compact || {};
    const hasSchedule = (name) => !!(name && compact[sanitize(name)]);

    const shadingSurfaceNames = new Set();

    const siteSurfaces = Array.isArray(shading.siteSurfaces)
        ? shading.siteSurfaces
        : [];
    siteSurfaces.forEach((s) => {
        if (!s || !s.name) return;
        const name = sanitize(s.name);
        shadingSurfaceNames.add(name);

        if (!Array.isArray(s.vertices) || s.vertices.length < 3) {
            issues.push({
                severity: 'warning',
                message: `Shading site/building surface "${s.name}" has fewer than 3 vertices and will be ignored.`,
            });
        }
        if (s.transmittanceScheduleName && !hasSchedule(s.transmittanceScheduleName)) {
            issues.push({
                severity: 'warning',
                message: `Shading surface "${s.name}" references missing transmittance schedule "${s.transmittanceScheduleName}".`,
            });
        }
    });

    const zoneSurfaces = Array.isArray(shading.zoneSurfaces)
        ? shading.zoneSurfaces
        : [];
    zoneSurfaces.forEach((s) => {
        if (!s || !s.name) return;
        const name = sanitize(s.name);
        shadingSurfaceNames.add(name);

        if (!s.baseSurfaceName) {
            issues.push({
                severity: 'warning',
                message: `Shading:Zone:Detailed "${s.name}" is missing baseSurfaceName.`,
            });
        }
        if (!Array.isArray(s.vertices) || s.vertices.length < 3) {
            issues.push({
                severity: 'warning',
                message: `Shading:Zone:Detailed "${s.name}" has fewer than 3 vertices and will be ignored.`,
            });
        }
        if (s.transmittanceScheduleName && !hasSchedule(s.transmittanceScheduleName)) {
            issues.push({
                severity: 'warning',
                message: `Shading:Zone:Detailed "${s.name}" references missing transmittance schedule "${s.transmittanceScheduleName}".`,
            });
        }
    });

    const refl = Array.isArray(shading.reflectance)
        ? shading.reflectance
        : [];
    refl.forEach((r) => {
        if (!r || !r.shadingSurfaceName) return;
        const sName = sanitize(r.shadingSurfaceName);
        if (!shadingSurfaceNames.has(sName)) {
            issues.push({
                severity: 'warning',
                message: `ShadingProperty:Reflectance references shading surface "${r.shadingSurfaceName}" which is not defined in shading.siteSurfaces/zoneSurfaces.`,
            });
        }
    });

    const ctrls = Array.isArray(shading.windowShadingControls)
        ? shading.windowShadingControls
        : [];
    ctrls.forEach((c) => {
        if (!c || !c.name) return;

        if (
            !Array.isArray(c.fenestrationSurfaceNames) ||
            !c.fenestrationSurfaceNames.length
        ) {
            issues.push({
                severity: 'warning',
                message: `WindowShadingControl "${c.name}" has no fenestrationSurfaceNames; it will not control any windows.`,
            });
        }

        if (c.scheduleName && !hasSchedule(c.scheduleName)) {
            issues.push({
                severity: 'warning',
                message: `WindowShadingControl "${c.name}" references missing schedule "${c.scheduleName}".`,
            });
        }

        if (c.setpoint1 != null && typeof c.setpoint1 !== 'number') {
            issues.push({
                severity: 'warning',
                message: `WindowShadingControl "${c.name}" has non-numeric setpoint1.`,
            });
        }
        if (c.setpoint2 != null && typeof c.setpoint2 !== 'number') {
            issues.push({
                severity: 'warning',
                message: `WindowShadingControl "${c.name}" has non-numeric setpoint2.`,
            });
        }

        // Additional sanity checks for obvious misconfigurations (non-fatal).
        const ct = String(c.controlType || '').toLowerCase();

        // Setpoint-based control types should have at least one numeric setpoint.
        if (
            /setpoint|onifhighsolar|onifhighglare|onifhight|onifhighsola|onifhightemp/.test(ct) &&
            c.setpoint1 == null
        ) {
            issues.push({
                severity: 'warning',
                message: `WindowShadingControl "${c.name}" uses a setpoint-based controlType "${c.controlType}" but setpoint1 is not defined.`,
            });
        }

        // MultipleSurfaceControlType is only meaningful when controlling multiple fenestration surfaces.
        if (
            c.multipleSurfaceControlType &&
            Array.isArray(c.fenestrationSurfaceNames) &&
            c.fenestrationSurfaceNames.length <= 1
        ) {
            issues.push({
                severity: 'warning',
                message: `WindowShadingControl "${c.name}" specifies Multiple Surface Control Type "${c.multipleSurfaceControlType}" but controls only one fenestration surface.`,
            });
        }
    });
}

/**
 * Compute geometry-level diagnostics from a normalized snapshot.
 */
function computeGeometryDiagnostics(geom, zoneNames) {
    const byZone = new Map();
    zoneNames.forEach((zn) => {
        byZone.set(zn, {
            name: zn,
            surfaces: {
                total: 0,
                exteriorWalls: 0,
                roofs: 0,
                floors: 0,
            },
            windows: {
                total: 0,
                totalArea: 0,
            },
            wwrByOrientation: {},
        });
    });

    const totals = {
        zones: zoneNames.length,
        exteriorWalls: 0,
        roofs: 0,
        floors: 0,
        windows: 0,
    };

    // Orientation bucketing helper
    const bucketOrientation = (azimuth) => {
        if (!Number.isFinite(azimuth)) return null;
        const a = ((azimuth % 360) + 360) % 360;
        if (a < 45 || a >= 315) return 'N';
        if (a >= 45 && a < 135) return 'E';
        if (a >= 135 && a < 225) return 'S';
        if (a >= 225 && a < 315) return 'W';
        return null;
    };

    // surfaces may be empty if geometry not available; then we keep defaults (zeros)
    (geom.surfaces || []).forEach((s) => {
        const zn = sanitize(s.zoneName || 'Zone_1');
        const z = byZone.get(zn);
        if (!z) return;

        z.surfaces.total += 1;

        const type = String(s.type || '').toLowerCase();
        const isExt = !!s.isExterior;
        const azimuth = typeof s.azimuth === 'number' ? s.azimuth : null;
        const grossArea = Number.isFinite(s.grossArea) ? s.grossArea : 0;

        if (isExt && grossArea > 0) {
            if (type.includes('wall')) {
                z.surfaces.exteriorWalls += 1;
                totals.exteriorWalls += 1;
            } else if (type.includes('roof') || type.includes('ceiling')) {
                z.surfaces.roofs += 1;
                totals.roofs += 1;
            } else if (type.includes('floor')) {
                z.surfaces.floors += 1;
                totals.floors += 1;
            }
        }

        // Subsurfaces (windows) for WWR
        if (Array.isArray(s.subsurfaces)) {
            s.subsurfaces.forEach((sub) => {
                const stype = String(sub.type || '').toLowerCase();
                const area = Number.isFinite(sub.area) ? sub.area : 0;
                if (stype.includes('window') && area > 0) {
                    z.windows.total += 1;
                    z.windows.totalArea += area;
                    totals.windows += 1;

                    const dir = isExt ? bucketOrientation(azimuth) : null;
                    if (dir) {
                        const key = `__wwr_acc_${dir}`;
                        const wallKey = `__wall_acc_${dir}`;
                        z[wallKey] = (z[wallKey] || 0) + grossArea;
                        z[key] = (z[key] || 0) + area;
                    }
                }
            });
        }
    });

    // Compute WWR per orientation using accumulated values
    byZone.forEach((z) => {
        const wwr = {};
        ['N', 'E', 'S', 'W'].forEach((dir) => {
            const wallArea = z[`__wall_acc_${dir}`] || 0;
            const winArea = z[`__wwr_acc_${dir}`] || 0;
            if (wallArea > 0 && winArea > 0) {
                wwr[dir] = +(winArea / wallArea).toFixed(3);
            }
            delete z[`__wall_acc_${dir}`];
            delete z[`__wwr_acc_${dir}`];
        });
        z.wwrByOrientation = wwr;
    });

    return {
        zones: Array.from(byZone.values()),
        totals,
    };
}

/**
 * Safely build a geometry snapshot from the current parametric model.
 * For now, we support the single-room parametric model defined in geometry.js.
 *
 * Snapshot is conservative and will not throw if geometry is unavailable.
 */
function getGeometrySnapshotSafe(issues) {
    const snapshot = {
        zones: [],
        surfaces: [],
    };

    try {
        // For the current parametric model:
        // - Single thermal zone: "Zone_1"
        // - Four walls (N,S,E,W) defined via getAllWindowParams() and room dimensions.
        // We do not import geometry.js to keep the builder environment-agnostic,
        // but we can approximate from project metadata if present.

        const meta = project?.getMetadata?.() || project?.metadata || {};
        const room = meta.room || meta.geometry || null;

        if (!room) {
            // Fallback: if no metadata, just declare one zone with no explicit surfaces.
            snapshot.zones.push({ name: 'Zone_1' });
            return snapshot;
        }

        const zoneName = room.name || 'Zone_1';
        snapshot.zones.push({ name: zoneName });

        const W = Number(room.width) || Number(room.W) || 0;
        const L = Number(room.length) || Number(room.L) || 0;
        const H = Number(room.height) || Number(room.H) || 0;
        const wwrMeta = room.windows || {};

        // Helper to push a surface
        const addSurface = (cfg) => {
            snapshot.surfaces.push({
                id: cfg.id,
                zoneName: zoneName,
                type: cfg.type,
                isExterior: true,
                azimuth: cfg.azimuth,
                grossArea: cfg.grossArea,
                netArea: cfg.grossArea, // no cutouts applied here
                constructionName: cfg.constructionName,
                subsurfaces: cfg.subsurfaces || [],
            });
        };

        if (W > 0 && L > 0 && H > 0) {
            // North wall (facing -Z): azimuth 0
            addSurface({
                id: 'Wall_N',
                type: 'Wall',
                azimuth: 0,
                grossArea: W * H,
                constructionName: null,
                subsurfaces: buildWindowSubs(wwrMeta.N, W, H),
            });
            // South wall (facing +Z): azimuth 180
            addSurface({
                id: 'Wall_S',
                type: 'Wall',
                azimuth: 180,
                grossArea: W * H,
                constructionName: null,
                subsurfaces: buildWindowSubs(wwrMeta.S, W, H),
            });
            // West wall (facing -X): azimuth 270
            addSurface({
                id: 'Wall_W',
                type: 'Wall',
                azimuth: 270,
                grossArea: L * H,
                constructionName: null,
                subsurfaces: buildWindowSubs(wwrMeta.W, L, H),
            });
            // East wall (facing +X): azimuth 90
            addSurface({
                id: 'Wall_E',
                type: 'Wall',
                azimuth: 90,
                grossArea: L * H,
                constructionName: null,
                subsurfaces: buildWindowSubs(wwrMeta.E, L, H),
            });

            // Simple roof/floor placeholders
            snapshot.surfaces.push({
                id: 'Roof',
                zoneName,
                type: 'Roof',
                isExterior: true,
                azimuth: NaN,
                grossArea: W * L,
                netArea: W * L,
                constructionName: null,
                subsurfaces: [],
            });
            snapshot.surfaces.push({
                id: 'Floor',
                zoneName,
                type: 'Floor',
                isExterior: true,
                azimuth: NaN,
                grossArea: W * L,
                netArea: W * L,
                constructionName: null,
                subsurfaces: [],
            });
        } else {
            // If room dimensions are not valid, keep a minimal snapshot.
            snapshot.zones.push({ name: 'Zone_1' });
        }
    } catch (e) {
        if (issues) {
            issues.push({
                severity: 'warning',
                message: 'Geometry diagnostics unavailable; falling back to configuration-only diagnostics.',
            });
        }
    }

    return snapshot;
}

/**
 * Build window subsurfaces array from a simple metadata description.
 * This is a placeholder using WWR-like info if available; otherwise returns [].
 */
function buildWindowSubs(winMeta, wallWidth, wallHeight) {
    if (!winMeta || typeof winMeta.wwr !== 'number' || winMeta.wwr <= 0) {
        return [];
    }
    const wallArea = wallWidth * wallHeight;
    const winArea = Math.max(0, Math.min(1, winMeta.wwr)) * wallArea;
    if (!winArea) return [];
    return [
        {
            id: 'Win_1',
            type: 'Window',
            area: winArea,
            constructionName: null,
        },
    ];
}

/**
 * Compute construction diagnostics based on defaults and construction library.
 */
function computeConstructionsDiagnostics(defaults, constructionLib) {
    const usedConstructionNames = new Set();
    const missingConstructions = new Set();
    const missingFromDefaults = new Set();

    const defaultCons = {
        wall: defaults?.wallConstruction,
        roof: defaults?.roofConstruction,
        floor: defaults?.floorConstruction,
        window: defaults?.windowConstruction,
    };

    Object.values(defaultCons).forEach((name) => {
        if (!name) return;
        const key = sanitize(name);
        if (constructionLib.has(key)) {
            usedConstructionNames.add(key);
        } else {
            missingConstructions.add(key);
            missingFromDefaults.add(key);
        }
    });

    const allConstructionNames = Array.from(constructionLib.keys());
    const unusedConstructions = allConstructionNames.filter(
        (n) => !usedConstructionNames.has(n)
    );

    const constructionsDiagnostics = {
        usedConstructions: Array.from(
            new Set([...usedConstructionNames, ...missingConstructions])
        ).map((name) => ({
            name,
            missing: missingConstructions.has(name),
        })),
        missingConstructions: Array.from(missingConstructions),
        unusedConstructions,
    };

    return { constructionsDiagnostics, missingConstructionsFromDefaults: missingFromDefaults };
}

/**
 * Compute materials diagnostics from construction library usage.
 */
function computeMaterialsDiagnostics(constructionLib, materialLib, issues) {
    const usedMaterialNames = new Set();
    const missingMaterials = new Set();

    constructionLib.forEach((c) => {
        (c.layers || []).forEach((ln) => {
            const key = sanitize(ln);
            if (materialLib.has(key)) {
                usedMaterialNames.add(key);
            } else {
                missingMaterials.add(key);
            }
        });
    });

    if (missingMaterials.size && issues) {
        issues.push({
            severity: 'error',
            message: `One or more constructions reference missing materials: ${Array.from(
                missingMaterials
            ).join(', ')}`,
        });
    }

    const allMaterialNames = Array.from(materialLib.keys());
    const unusedMaterials = allMaterialNames.filter(
        (n) => !usedMaterialNames.has(n)
    );

    return {
        missingMaterials: Array.from(missingMaterials),
        unusedMaterials,
    };
}

/**
 * Compute schedules and loads diagnostics.
 */
function computeSchedulesAndLoadsDiagnostics(
    scheduleCtx,
    loads,
    idealLoads,
    thermostats,
    daylighting,
    issues
) {
    const compactSchedules = scheduleCtx.compact || {};
    const scheduleExists = (name) => {
        if (!name) return false;
        const key = sanitize(name);
        return !!compactSchedules[key];
    };

    const missingScheduleNames = new Set();
    const inconsistentLoads = [];

    // Zone loads
    (loads || []).forEach((l) => {
        if (!l || !l.zoneName) return;
        const zn = sanitize(l.zoneName);
        const check = (field, schedName) => {
            if (!schedName) return;
            if (!scheduleExists(schedName)) {
                missingScheduleNames.add(schedName);
                inconsistentLoads.push({
                    zone: zn,
                    issue: `${field} schedule "${schedName}" is not defined.`,
                });
            }
        };

        if (l.people) check('People', l.people.schedule);
        if (l.lighting) check('Lighting', l.lighting.schedule);
        if (l.equipment) check('Equipment', l.equipment.schedule);
        if (l.infiltration) check('Infiltration', l.infiltration.schedule);
    });

    // IdealLoads availability
    if (idealLoads) {
        const g = idealLoads.global || {};
        if (g.availabilitySchedule && !scheduleExists(g.availabilitySchedule)) {
            missingScheduleNames.add(g.availabilitySchedule);
            issues.push({
                severity: 'warning',
                message: `IdealLoads global availability schedule "${g.availabilitySchedule}" is not defined.`,
            });
        }
        (idealLoads.perZone || []).forEach((cfg) => {
            if (!cfg || !cfg.zoneName || !cfg.availabilitySchedule) return;
            if (!scheduleExists(cfg.availabilitySchedule)) {
                missingScheduleNames.add(cfg.availabilitySchedule);
                issues.push({
                    severity: 'warning',
                    message: `IdealLoads availability schedule "${cfg.availabilitySchedule}" for zone "${cfg.zoneName}" is not defined.`,
                });
            }
        });
    }

    // Thermostats
    (thermostats || []).forEach((t) => {
        if (!t) return;
        const heat = t.heatingScheduleName;
        const cool = t.coolingScheduleName;
        if (heat && !scheduleExists(heat)) {
            missingScheduleNames.add(heat);
            issues.push({
                severity: 'warning',
                message: `Thermostat heating schedule "${heat}" is not defined.`,
            });
        }
        if (cool && !scheduleExists(cool)) {
            missingScheduleNames.add(cool);
            issues.push({
                severity: 'warning',
                message: `Thermostat cooling schedule "${cool}" is not defined.`,
            });
        }
    });

    // Daylighting outputs: no schedule references to validate currently.

    return {
        missingSchedules: Array.from(missingScheduleNames),
        inconsistentLoads,
    };
}

/**
 * THERMOSTATS + IDEAL LOADS
 *
 * Full-fidelity mapping for:
 *  - ZoneControl:Thermostat + ThermostatSetpoint:* (classic modes 0–4)
 *  - ZoneHVAC:IdealLoadsAirSystem (key documented fields)
 *
 * Backward compatible with legacy:
 *  - thermostats: [{ zoneName, heatingScheduleName, coolingScheduleName }]
 *  - idealLoads.global / idealLoads.perZone with limited fields.
 */
function emitThermostatsAndIdealLoads(
    idf,
    zones,
    scheduleContext,
    idealLoads = {},
    thermostats = {}
) {
    const znList = zones.length ? zones : [{ name: 'Zone_1' }];
    const compact = scheduleContext.compact || {};

    const getSched = (name) => {
        if (!name) return null;
        const key = sanitize(name);
        return compact[key] ? key : null;
    };

    // Normalize thermostats schema:
    // - New schema: { setpoints, zoneControls }
    // - Legacy array: [{ zoneName, heatingScheduleName, coolingScheduleName }]
    const setpointsMap = new Map();
    const zoneControls = [];

    if (Array.isArray(thermostats)) {
        // Legacy: create DualSetpoint controls from heating/cooling schedules
        thermostats.forEach((t) => {
            if (!t) return;
            const zn = t.zoneName ? sanitize(t.zoneName) : 'GLOBAL';
            const heat = t.heatingScheduleName;
            const cool = t.coolingScheduleName;
            if (!heat && !cool) return;

            const spName = `SP_Dual_${zn}`;
            setpointsMap.set(spName, {
                type: 'DualSetpoint',
                heatingSchedule: heat,
                coolingSchedule: cool,
            });

            zoneControls.push({
                zoneName: zn,
                controlTypeScheduleName: '', // default: always dual setpoint
                dualSetpointName: spName,
            });
        });
    } else {
        const sp = thermostats.setpoints || {};
        Object.keys(sp).forEach((name) => {
            const def = sp[name];
            if (!def || !def.type) return;
            const key = sanitize(name);
            if (!setpointsMap.has(key)) {
                setpointsMap.set(key, { ...def, name: key });
            }
        });

        (thermostats.zoneControls || []).forEach((c) => {
            if (!c || !c.zoneName) return;
            zoneControls.push({
                zoneName: c.zoneName,
                controlTypeScheduleName: c.controlTypeScheduleName || '',
                singleHeatingSetpointName: c.singleHeatingSetpointName,
                singleCoolingSetpointName: c.singleCoolingSetpointName,
                singleHeatCoolSetpointName: c.singleHeatCoolSetpointName,
                dualSetpointName: c.dualSetpointName,
                cutoutDeltaT: c.cutoutDeltaT,
            });
        });
    }

    // Helper: emit ThermostatSetpoint objects from setpointsMap
    function emitSetpoints() {
        setpointsMap.forEach((sp, key) => {
            const type = sp.type;
            if (type === 'SingleHeating') {
                const sch = getSched(sp.schedule || sp.heatingSchedule);
                if (!sch) return;
                idf.push(`ThermostatSetpoint:SingleHeating,`);
                idf.push(`  ${key},                 !- Name`);
                idf.push(`  ${sch};                !- Setpoint Temperature Schedule Name`);
                idf.push('');
            } else if (type === 'SingleCooling') {
                const sch = getSched(sp.schedule || sp.coolingSchedule);
                if (!sch) return;
                idf.push(`ThermostatSetpoint:SingleCooling,`);
                idf.push(`  ${key},                 !- Name`);
                idf.push(`  ${sch};                !- Setpoint Temperature Schedule Name`);
                idf.push('');
            } else if (type === 'SingleHeatingOrCooling') {
                const sch = getSched(sp.schedule);
                if (!sch) return;
                idf.push(`ThermostatSetpoint:SingleHeatingOrCooling,`);
                idf.push(`  ${key},                 !- Name`);
                idf.push(`  ${sch};                !- Setpoint Temperature Schedule Name`);
                idf.push('');
            } else if (type === 'DualSetpoint') {
                const hSch = getSched(sp.heatingSchedule);
                const cSch = getSched(sp.coolingSchedule);
                idf.push(`ThermostatSetpoint:DualSetpoint,`);
                idf.push(`  ${key},                 !- Name`);
                idf.push(`  ${hSch || ''},          !- Heating Setpoint Temperature Schedule Name`);
                idf.push(`  ${cSch || ''};          !- Cooling Setpoint Temperature Schedule Name`);
                idf.push('');
            }
        });
    }

    // Emit setpoints before ZoneControl:Thermostat
    emitSetpoints();

    // Index zone controls by zone (and handle GLOBAL)
    const zoneCtrlByZone = new Map();
    zoneControls.forEach((c) => {
        const zn = c.zoneName ? sanitize(c.zoneName) : 'GLOBAL';
        zoneCtrlByZone.set(zn, c);
    });

    // Emit ZoneControl:Thermostat per zone if configured
    znList.forEach((z, idx) => {
        const zn = sanitize(z.name || `Zone_${idx + 1}`);
        const ctrl =
            zoneCtrlByZone.get(zn) ||
            zoneCtrlByZone.get('GLOBAL');

        if (!ctrl) return;

        const ctSchedule = getSched(ctrl.controlTypeScheduleName) || '';
        const pairs = [];

        if (ctrl.singleHeatingSetpointName) {
            pairs.push({
                type: 'ThermostatSetpoint:SingleHeating',
                name: sanitize(ctrl.singleHeatingSetpointName),
            });
        }
        if (ctrl.singleCoolingSetpointName) {
            pairs.push({
                type: 'ThermostatSetpoint:SingleCooling',
                name: sanitize(ctrl.singleCoolingSetpointName),
            });
        }
        if (ctrl.singleHeatCoolSetpointName) {
            pairs.push({
                type: 'ThermostatSetpoint:SingleHeatingOrCooling',
                name: sanitize(ctrl.singleHeatCoolSetpointName),
            });
        }
        if (ctrl.dualSetpointName) {
            pairs.push({
                type: 'ThermostatSetpoint:DualSetpoint',
                name: sanitize(ctrl.dualSetpointName),
            });
        }

        // Fallback for legacy: if no pairs but we have a dual setpoint setpoint
        if (!pairs.length && ctrl.dualSetpointName) {
            pairs.push({
                type: 'ThermostatSetpoint:DualSetpoint',
                name: sanitize(ctrl.dualSetpointName),
            });
        }

        if (!pairs.length) return;

        idf.push(`ZoneControl:Thermostat,`);
        idf.push(`  Tstat_${zn},              !- Name`);
        idf.push(`  ${zn},                    !- Zone or ZoneList Name`);
        idf.push(`  ${ctSchedule},            !- Control Type Schedule Name`);

        pairs.forEach((p, i) => {
            const suffix = i === pairs.length - 1 ? ';' : ',';
            idf.push(
                `  ${p.type},           !- Control ${i + 1} Object Type${i ? '' : ''}`
            );
            idf.push(
                `  ${p.name}${suffix}           !- Control ${i + 1} Name`
            );
        });

        idf.push('');
        // Note: cutoutDeltaT exposed in UI can be supported via
        //  ZoneControl:Thermostat:TemperatureAndHumidity or EMS; omitted here intentionally.
    });

    // IdealLoads: merge global/per-zone configuration and emit ZoneHVAC:IdealLoadsAirSystem
    const globalCfg = idealLoads.global || {};
    const perZoneCfg = Array.isArray(idealLoads.perZone) ? idealLoads.perZone : [];

    znList.forEach((z, idx) => {
        const zn = sanitize(z.name || `Zone_${idx + 1}`);

        const zCfgRaw =
            perZoneCfg.find(
                (c) => c.zoneName && sanitize(c.zoneName) === zn
            ) || {};

        const cfg = { ...globalCfg, ...zCfgRaw };

        const avail = getSched(
            cfg.availabilitySchedule || 'RM_AlwaysOn'
        ) || 'RM_AlwaysOn';

        const heatLimit =
            cfg.heatingLimitType || 'NoLimit';
        const coolLimit =
            cfg.coolingLimitType || 'NoLimit';

        const maxHeatFlow = cfg.maxHeatingAirFlowRate;
        const maxCoolFlow = cfg.maxCoolingAirFlowRate;
        const maxHeatCap = cfg.maxSensibleHeatingCapacity ?? cfg.maxHeatingCapacity;
        const maxCoolCap = cfg.maxTotalCoolingCapacity ?? cfg.maxCoolingCapacity;

        const heatAvail = getSched(cfg.heatingAvailabilitySchedule) || '';
        const coolAvail = getSched(cfg.coolingAvailabilitySchedule) || '';

        const dehumType = cfg.dehumidificationControlType || '';
        const coolSHR =
            typeof cfg.coolingSensibleHeatRatio === 'number'
                ? cfg.coolingSensibleHeatRatio
                : '';

        const humType = cfg.humidificationControlType || '';

        const dcvType = cfg.demandControlledVentilationType || 'None';
        const econType = cfg.outdoorAirEconomizerType || 'NoEconomizer';

        const hrType = cfg.heatRecoveryType || 'None';
        const hrSensEff = cfg.sensibleHeatRecoveryEffectiveness;
        const hrLatEff = cfg.latentHeatRecoveryEffectiveness;

        // Supply T/RH
        const maxHeatSupT = cfg.maxHeatingSupplyAirTemp;
        const minCoolSupT = cfg.minCoolingSupplyAirTemp;
        const maxHeatSupW = cfg.maxHeatingSupplyAirHumRat;
        const minCoolSupW = cfg.minCoolingSupplyAirHumRat;

        // OA method/flows: support legacy + new
        const oaMethod = cfg.outdoorAirMethod || 'None';
        const oaPP = cfg.outdoorAirFlowPerPerson;
        const oaPA = cfg.outdoorAirFlowPerArea;

        idf.push(`ZoneHVAC:IdealLoadsAirSystem,`);
        idf.push(`  IdealLoads_${zn},          !- Name`);
        idf.push(`  ${avail},                  !- Availability Schedule Name`);
        idf.push(
            `  ,                           !- Zone Supply Air Node Name (auto-wired downstream)`
        );
        idf.push(
            `  ,                           !- Zone Exhaust Air Node Name (auto-wired downstream)`
        );
        idf.push(
            `  ,                           !- System Inlet Air Node Name (auto/optional)`
        );
        idf.push(
            `  ${maxHeatSupT != null ? maxHeatSupT : 50}, !- Maximum Heating Supply Air Temperature {C}`
        );
        idf.push(
            `  ${minCoolSupT != null ? minCoolSupT : 13}, !- Minimum Cooling Supply Air Temperature {C}`
        );
        idf.push(
            `  ${maxHeatSupW != null ? maxHeatSupW : 0.0156}, !- Maximum Heating Supply Air Humidity Ratio {kgWater/kgDryAir}`
        );
        idf.push(
            `  ${minCoolSupW != null ? minCoolSupW : 0.0077}, !- Minimum Cooling Supply Air Humidity Ratio {kgWater/kgDryAir}`
        );
        idf.push(`  ${heatLimit},              !- Heating Limit`);
        idf.push(
            `  ${maxHeatFlow != null ? maxHeatFlow : ''}, !- Maximum Heating Air Flow Rate {m3/s}`
        );
        idf.push(
            `  ${maxHeatCap != null ? maxHeatCap : ''}, !- Maximum Sensible Heating Capacity {W}`
        );
        idf.push(`  ${coolLimit},              !- Cooling Limit`);
        idf.push(
            `  ${maxCoolFlow != null ? maxCoolFlow : ''}, !- Maximum Cooling Air Flow Rate {m3/s}`
        );
        idf.push(
            `  ${maxCoolCap != null ? maxCoolCap : ''}, !- Maximum Total Cooling Capacity {W}`
        );
        idf.push(
            `  ${heatAvail || ''},          !- Heating Availability Schedule Name`
        );
        idf.push(
            `  ${coolAvail || ''},          !- Cooling Availability Schedule Name`
        );
        idf.push(
            `  ${dehumType || 'None'},      !- Dehumidification Control Type`
        );
        idf.push(
            `  ${coolSHR !== '' ? coolSHR : ''}, !- Cooling Sensible Heat Ratio {dimensionless}`
        );
        idf.push(
            `  ,                           !- Dehumidification Setpoint (unused; use humidistat objects)`
        );
        idf.push(
            `  ${humType || 'None'},        !- Humidification Control Type`
        );
        idf.push(
            `  ,                           !- Humidification Setpoint (unused; use humidistat objects)`
        );
        idf.push(
            `  ${econType},                 !- Outdoor Air Economizer Type`
        );
        idf.push(
            `  ${hrType},                   !- Heat Recovery Type`
        );
        idf.push(
            `  ${hrSensEff != null ? hrSensEff : ''}, !- Sensible Heat Recovery Effectiveness`
        );
        idf.push(
            `  ${hrLatEff != null ? hrLatEff : ''}, !- Latent Heat Recovery Effectiveness`
        );

        // DesignSpecification:OutdoorAir, DCV, etc. are advanced; allow explicit binding via config
        const dsOa = cfg.designSpecOutdoorAirObjectName || '';
        const dcv = dcvType || 'None';

        // Following 4 OA fields map to:
        //  - Design Specification Outdoor Air Object Name
        //  - Outdoor Air Inlet Node Name
        //  - Demand Controlled Ventilation Type
        //  - Outdoor Air Economizer Type (already emitted)
        idf.push(
            `  ${dsOa},                     !- Design Specification Outdoor Air Object Name`
        );
        idf.push(
            `  ,                           !- Outdoor Air Inlet Node Name (auto if blank)`
        );
        idf.push(
            `  ${dcv},                      !- Demand Controlled Ventilation Type`
        );

        // Heat recovery fields already emitted; remaining OA flow parameters:
        if (oaMethod !== 'None') {
            idf.push(
                `  ${oaMethod},              !- Outdoor Air Method`
            );
            idf.push(
                `  ${oaPP != null ? oaPP : ''}, !- Outdoor Air Flow per Person {m3/s-person}`
            );
            idf.push(
                `  ${oaPA != null ? oaPA : ''}, !- Outdoor Air Flow per Zone Floor Area {m3/s-m2}`
            );
            idf.push(
                `  ,                           !- Outdoor Air Flow per Zone {m3/s}`
            );
            idf.push(
                `  ;                           !- Outdoor Air Flow Air Changes per Hour {1/hr}`
            );
        } else {
            idf.push(`  None,                    !- Outdoor Air Method`);
            idf.push(
                `  ,                           !- Outdoor Air Flow per Person {m3/s-person}`
            );
            idf.push(
                `  ,                           !- Outdoor Air Flow per Zone Floor Area {m3/s-m2}`
            );
            idf.push(
                `  ,                           !- Outdoor Air Flow per Zone {m3/s}`
            );
            idf.push(
                `  ;                           !- Outdoor Air Flow Air Changes per Hour {1/hr}`
            );
        }

        idf.push('');
    });
}

/**
 * MATERIALS
 */
function buildMaterialLibrary(userMaterials = [], epDefaults) {
    const lib = new Map();

    if (epDefaults && epDefaults.materials) {
        const m = epDefaults.materials;

        (m['Material'] || []).forEach((mat) => {
            if (!mat || !mat.Name) return;
            const key = sanitize(mat.Name);
            if (!lib.has(key)) {
                lib.set(key, {
                    type: 'Material',
                    name: key,
                    roughness: mat.Roughness,
                    thickness: mat.Thickness_m,
                    conductivity: mat.Conductivity_W_mK,
                    density: mat.Density_kg_m3,
                    specificHeat: mat.SpecificHeat_J_kgK,
                    solarAbsorptance: mat.SolarAbsorptance,
                    thermalAbsorptance: mat.ThermalAbsorptance,
                    visibleAbsorptance: mat.VisibleAbsorptance,
                });
            }
        });

        (m['Material:AirGap'] || []).forEach((mat) => {
            if (!mat || !mat.Name) return;
            const key = sanitize(mat.Name);
            if (!lib.has(key)) {
                lib.set(key, {
                    type: 'Material:AirGap',
                    name: key,
                    thermalResistance: mat.ThermalResistance_m2K_W,
                });
            }
        });

        (m['WindowMaterial:Glazing'] || []).forEach((mat) => {
            if (!mat || !mat.Name) return;
            const key = sanitize(mat.Name);
            if (!lib.has(key)) {
                lib.set(key, {
                    type: 'WindowMaterial:Glazing',
                    name: key,
                    opticalDataType: mat.OpticalDataType,
                    thickness: mat.Thickness_m,
                    solarTransmittance: mat.SolarTransmittance,
                    frontSolarReflectance: mat.FrontSolarReflectance,
                    backSolarReflectance: mat.BackSolarReflectance,
                    visibleTransmittance: mat.VisibleTransmittance,
                    frontVisibleReflectance: mat.FrontVisibleReflectance,
                    backVisibleReflectance: mat.BackVisibleReflectance,
                    infraredTransmittance: mat.InfraredTransmittance,
                    frontEmissivity: mat.FrontIRHemisphericalEmissivity,
                    backEmissivity: mat.BackIRHemisphericalEmissivity,
                    conductivity: mat.Conductivity_W_mK,
                });
            }
        });

        (m['WindowMaterial:Gas'] || []).forEach((mat) => {
            if (!mat || !mat.Name) return;
            const key = sanitize(mat.Name);
            if (!lib.has(key)) {
                lib.set(key, {
                    type: 'WindowMaterial:Gas',
                    name: key,
                    gasType: mat.GasType,
                    thickness: mat.Thickness_m,
                });
            }
        });

        (m['WindowMaterial:Shade'] || []).forEach((mat) => {
            if (!mat || !mat.Name) return;
            const key = sanitize(mat.Name);
            if (!lib.has(key)) {
                lib.set(key, {
                    type: 'WindowMaterial:Shade',
                    name: key,
                    solarTransmittance: mat.SolarTransmittance,
                    solarReflectance: mat.SolarReflectance,
                    visibleTransmittance: mat.VisibleTransmittance,
                    visibleReflectance: mat.VisibleReflectance,
                    irEmissivity: mat.IRHemisphericalEmissivity,
                    irTransmittance: mat.IRTransmittance,
                    thickness: mat.Thickness_m,
                    conductivity: mat.Conductivity_W_mK,
                    shadeToGlassDistance: mat.ShadeToGlassDistance_m,
                });
            }
        });
    }

    (userMaterials || []).forEach((m) => {
        if (!m || !m.name) return;
        const key = sanitize(m.name);
        if (!lib.has(key)) {
            lib.set(key, { ...m, name: key });
        }
    });

    return lib;
}

function emitMaterials(idf, lib) {
    for (const m of lib.values()) {
        if (m.type === 'WindowMaterial:SimpleGlazingSystem') {
            idf.push(`WindowMaterial:SimpleGlazingSystem,`);
            idf.push(`  ${m.name},               !- Name`);
            idf.push(`  ${m.uFactor ?? 2.7},    !- U-Factor {W/m2-K}`);
            idf.push(`  ${m.solarHeatGainCoeff ?? 0.65}, !- Solar Heat Gain Coefficient`);
            idf.push(`  ${m.visibleTransmittance ?? 0.78}; !- Visible Transmittance`);
            idf.push('');
        } else if (m.type === 'Material:NoMass') {
            idf.push(`Material:NoMass,`);
            idf.push(`  ${m.name},               !- Name`);
            idf.push(`  ${m.roughness || 'Rough'}, !- Roughness`);
            idf.push(`  ${m.thermalResistance ?? 1.0}, !- Thermal Resistance {m2-K/W}`);
            idf.push(`  ${m.solarAbsorptance ?? 0.6}, !- Solar Absorptance`);
            idf.push(`  ${m.thermalAbsorptance ?? 0.9}, !- Thermal Absorptance`);
            idf.push(`  ${m.visibleAbsorptance ?? 0.6}; !- Visible Absorptance`);
            idf.push('');
        } else {
            idf.push(`Material,`);
            idf.push(`  ${m.name},               !- Name`);
            idf.push(`  ${m.roughness || 'MediumRough'}, !- Roughness`);
            idf.push(`  ${m.thickness ?? 0.1},  !- Thickness {m}`);
            idf.push(`  ${m.conductivity ?? 0.5}, !- Conductivity {W/m-K}`);
            idf.push(`  ${m.density ?? 800},    !- Density {kg/m3}`);
            idf.push(`  ${m.specificHeat ?? 1000}, !- Specific Heat {J/kg-K}`);
            idf.push(`  ${m.solarAbsorptance ?? 0.6}, !- Solar Absorptance`);
            idf.push(`  ${m.thermalAbsorptance ?? 0.9}, !- Thermal Absorptance`);
            idf.push(`  ${m.visibleAbsorptance ?? 0.6}; !- Visible Absorptance`);
            idf.push('');
        }
    }
}

/**
 * CONSTRUCTIONS
 */
function buildConstructionLibrary(userConstructions = [], materialLibrary) {
    const lib = new Map();

    const builtin = [];
    if (energyplusDefaults && typeof energyplusDefaults.getConstructionDefaults === 'function') {
        const defaultsCons = energyplusDefaults.getConstructionDefaults();
        defaultsCons.forEach((c) => {
            if (!c || !c.Name || !Array.isArray(c.Layers)) return;
            builtin.push({
                name: c.Name,
                layers: c.Layers,
            });
        });
    }

    [...builtin, ...(userConstructions || [])].forEach((c) => {
        if (!c || !c.name || !Array.isArray(c.layers) || !c.layers.length) return;
        const key = sanitize(c.name);
        if (!lib.has(key)) {
            const validLayers = c.layers
                .map((ln) => sanitize(ln))
                .filter((ln) => materialLibrary.has(ln));
            if (validLayers.length) {
                lib.set(key, { name: key, layers: validLayers });
            }
        }
    });

    return lib;
}

function emitConstructions(idf, lib) {
    for (const c of lib.values()) {
        idf.push(`Construction,`);
        idf.push(`  ${c.name},                 !- Name`);
        c.layers.forEach((layer, idx) => {
            const suffix = idx === c.layers.length - 1 ? ';' : ',';
            idf.push(`  ${layer}${suffix}              !- Layer ${idx + 1}`);
        });
        idf.push('');
    }
}

/**
 * SCHEDULES
 */
function buildSchedules(userSchedules = {}) {
    const builtinCompact = {
        RM_AlwaysOn: {
            typeLimits: 'Fraction',
            lines: ['Through: 12/31', 'For: AllDays', 'Until: 24:00, 1.0'],
        },
        RM_Office_Occ: {
            typeLimits: 'Fraction',
            lines: [
                'Through: 12/31',
                'For: Weekdays',
                'Until: 08:00, 0.0',
                'Until: 09:00, 0.2',
                'Until: 12:00, 0.9',
                'Until: 13:00, 0.7',
                'Until: 18:00, 0.9',
                'Until: 24:00, 0.05',
                'For: Weekends',
                'Until: 24:00, 0.05',
            ],
        },
        RM_Office_Lighting: {
            typeLimits: 'Fraction',
            lines: [
                'Through: 12/31',
                'For: Weekdays',
                'Until: 08:00, 0.0',
                'Until: 18:00, 1.0',
                'Until: 24:00, 0.1',
                'For: Weekends',
                'Until: 24:00, 0.1',
            ],
        },
        RM_Office_Equipment: {
            typeLimits: 'Fraction',
            lines: [
                'Through: 12/31',
                'For: Weekdays',
                'Until: 08:00, 0.2',
                'Until: 18:00, 1.0',
                'Until: 24:00, 0.5',
                'For: Weekends',
                'Until: 24:00, 0.3',
            ],
        },
    };

    const schedules = {
        compact: { ...builtinCompact },
    };

    if (userSchedules && typeof userSchedules === 'object') {
        if (Array.isArray(userSchedules.compact)) {
            userSchedules.compact.forEach((s) => {
                if (!s || !s.name || !Array.isArray(s.lines) || !s.lines.length) return;
                const key = sanitize(s.name);
                schedules.compact[key] = {
                    typeLimits: s.typeLimits || 'Fraction',
                    lines: s.lines.slice(),
                };
            });
        } else if (typeof userSchedules.compact === 'object') {
            Object.keys(userSchedules.compact).forEach((name) => {
                const s = userSchedules.compact[name];
                if (!s || !Array.isArray(s.lines) || !s.lines.length) return;
                const key = sanitize(name);
                schedules.compact[key] = {
                    typeLimits: s.typeLimits || 'Fraction',
                    lines: s.lines.slice(),
                };
            });
        }
    }

    return schedules;
}

function emitSchedules(idf, scheduleContext) {
    idf.push(`ScheduleTypeLimits,`);
    idf.push(`  Fraction,                 !- Name`);
    idf.push(`  0.0,                      !- Lower Limit Value`);
    idf.push(`  1.0,                      !- Upper Limit Value`);
    idf.push(`  CONTINUOUS;               !- Numeric Type`);
    idf.push('');

    const compact = scheduleContext.compact || {};
    Object.keys(compact).forEach((name) => {
        const s = compact[name];
        idf.push(`Schedule:Compact,`);
        idf.push(`  ${name},                  !- Name`);
        idf.push(`  ${s.typeLimits || 'Fraction'}, !- Schedule Type Limits Name`);
        s.lines.forEach((line, idx) => {
            const suffix = idx === s.lines.length - 1 ? ';' : ',';
            idf.push(`  ${line}${suffix}`);
        });
        idf.push('');
    });
}

/**
 * LOADS
 */
function emitZoneLoads(idf, zones, loads = [], scheduleContext) {
    const znIndex = new Map();
    const znList = zones.length ? zones : [{ name: 'Zone_1' }];
    znList.forEach((z) => {
        znIndex.set(sanitize(z.name), sanitize(z.name));
    });

    const compact = scheduleContext.compact || {};
    const ensureSchedule = (name, fallback) => {
        const key = sanitize(name);
        if (compact[key]) return key;
        return fallback;
    };

    const AlwaysOn = ensureSchedule('RM_AlwaysOn', 'RM_AlwaysOn');

    (loads || []).forEach((l, i) => {
        if (!l || !l.zoneName) return;
        const zn = sanitize(l.zoneName);
        if (!znIndex.has(zn)) return;

        // People
        if (l.people && l.people.peoplePerArea) {
            const sch = ensureSchedule(
                l.people.schedule || 'RM_Office_Occ',
                AlwaysOn
            );
            idf.push(`People,`);
            idf.push(`  People_${zn}_${i},       !- Name`);
            idf.push(`  ${zn},                   !- Zone or ZoneList Name`);
            idf.push(`  ${sch},                  !- Number of People Schedule Name`);
            idf.push(`  People/Area,             !- Number of People Calculation Method`);
            idf.push(`  ,                        !- Number of People`);
            idf.push(`  ${l.people.peoplePerArea}, !- People per Zone Floor Area {person/m2}`);
            idf.push(`  ,                        !- People per Person`);
            idf.push(`  0.3,                     !- Fraction Radiant`);
            idf.push(`  0.5,                     !- Sensible Heat Fraction`);
            idf.push(`  ${l.people.activityLevel || 120}; !- Activity Level {W/person}`);
            idf.push('');
        }

        // Lights
        if (l.lighting && l.lighting.wattsPerArea) {
            const sch = ensureSchedule(
                l.lighting.schedule || 'RM_Office_Lighting',
                AlwaysOn
            );
            idf.push(`Lights,`);
            idf.push(`  Lights_${zn}_${i},       !- Name`);
            idf.push(`  ${zn},                   !- Zone or ZoneList Name`);
            idf.push(`  ${sch},                  !- Schedule Name`);
            idf.push(`  Watts/Area,              !- Design Level Calculation Method`);
            idf.push(`  ,                        !- Lighting Level {W}`);
            idf.push(`  ${l.lighting.wattsPerArea}, !- Watts per Zone Floor Area {W/m2}`);
            idf.push(`  ,                        !- Watts per Person {W/person}`);
            idf.push(`  0.0,                     !- Return Air Fraction`);
            idf.push(`  0.6,                     !- Fraction Radiant`);
            idf.push(`  0.2,                     !- Fraction Visible`);
            idf.push(`  0.0,                     !- Fraction Replaceable`);
            idf.push(`  General;                 !- End-Use Subcategory`);
            idf.push('');
        }

        // Equipment
        if (l.equipment && l.equipment.wattsPerArea) {
            const sch = ensureSchedule(
                l.equipment.schedule || 'RM_Office_Equipment',
                AlwaysOn
            );
            idf.push(`ElectricEquipment,`);
            idf.push(`  Equip_${zn}_${i},        !- Name`);
            idf.push(`  ${zn},                   !- Zone or ZoneList Name`);
            idf.push(`  ${sch},                  !- Schedule Name`);
            idf.push(`  Watts/Area,              !- Design Level Calculation Method`);
            idf.push(`  ,                        !- Design Level {W}`);
            idf.push(`  ${l.equipment.wattsPerArea}, !- Watts per Zone Floor Area {W/m2}`);
            idf.push(`  ,                        !- Watts per Person {W/person}`);
            idf.push(`  0.0,                     !- Fraction Latent`);
            idf.push(`  0.3,                     !- Fraction Radiant`);
            idf.push(`  0.7;                     !- Fraction Lost`);
            idf.push('');
        }

        // Infiltration
        if (l.infiltration && (l.infiltration.ach || l.infiltration.flowPerArea)) {
            const sch = ensureSchedule(
                l.infiltration.schedule || AlwaysOn,
                AlwaysOn
            );
            idf.push(`ZoneInfiltration:DesignFlowRate,`);
            idf.push(`  Infil_${zn}_${i},        !- Name`);
            idf.push(`  ${zn},                   !- Zone or ZoneList Name`);
            idf.push(`  ${sch},                  !- Schedule Name`);
            if (l.infiltration.ach) {
                idf.push(`  ,                        !- Design Flow Rate {m3/s}`);
                idf.push(`  ,                        !- Flow per Zone Floor Area {m3/s-m2}`);
                idf.push(`  ,                        !- Flow per Exterior Surface Area {m3/s-m2}`);
                idf.push(`  ${l.infiltration.ach};   !- Air Changes per Hour {1/hr}`);
            } else {
                idf.push(`  ,                        !- Design Flow Rate {m3/s}`);
                idf.push(`  ${l.infiltration.flowPerArea}, !- Flow per Zone Floor Area {m3/s-m2}`);
                idf.push(`  ,                        !- Flow per Exterior Surface Area {m3/s-m2}`);
                idf.push(`  ;                        !- Air Changes per Hour {1/hr}`);
            }
            idf.push('');
        }
    });
}

/**
 * NATURAL VENTILATION
 * Config: options.naturalVentilation.global / perZone
 * Emits ZoneVentilation:DesignFlowRate objects when enabled/configured.
 */
function emitZoneVentilation(idf, zones, natVentCfg = {}, scheduleContext = {}) {
    const znList = zones && zones.length ? zones : [{ name: 'Zone_1' }];
    const compact = scheduleContext.compact || {};

    const scheduleExists = (name) => {
        if (!name) return false;
        return !!compact[sanitize(name)];
    };

    const getAlwaysOn = () => {
        if (compact.RM_AlwaysOn) return 'RM_AlwaysOn';
        // Fallback: if not present (should not happen with current buildSchedules),
        // create a local AlwaysOn inline (won't be de-duped, but safe).
        idf.push(`Schedule:Compact,`);
        idf.push(`  RM_AlwaysOn,              !- Name`);
        idf.push(`  Fraction,                 !- Schedule Type Limits Name`);
        idf.push(`  Through: 12/31,`);
        idf.push(`  For: AllDays,`);
        idf.push(`  Until: 24:00, 1.0;`);
        idf.push('');
        compact.RM_AlwaysOn = { typeLimits: 'Fraction', lines: ['Through: 12/31', 'For: AllDays', 'Until: 24:00, 1.0'] };
        return 'RM_AlwaysOn';
    };

    const globalCfg = natVentCfg.global || {};
    const perZone = Array.isArray(natVentCfg.perZone) ? natVentCfg.perZone : [];

    const byZoneOverride = new Map();
    perZone.forEach((pz) => {
        if (!pz || !pz.zoneName) return;
        byZoneOverride.set(sanitize(pz.zoneName), pz);
    });

    const anyGlobalEnabled =
        globalCfg.enabled ||
        globalCfg.designFlowRate != null ||
        globalCfg.flowPerArea != null ||
        globalCfg.flowPerPerson != null ||
        globalCfg.airChangesPerHour != null;

    znList.forEach((z, idx) => {
        const zn = sanitize(z.name || `Zone_${idx + 1}`);
        const zCfgRaw = byZoneOverride.get(zn) || {};

        const enabled =
            zCfgRaw.enabled != null
                ? !!zCfgRaw.enabled
                : anyGlobalEnabled;

        if (!enabled) return;

        // Merge global + local overrides (local wins)
        const cfg = { ...globalCfg, ...zCfgRaw };

        // Determine method
        let method = cfg.calculationMethod;
        if (!method) {
            if (cfg.airChangesPerHour != null) method = 'AirChanges/Hour';
            else if (cfg.flowPerPerson != null) method = 'Flow/Person';
            else if (cfg.flowPerArea != null) method = 'Flow/Area';
            else if (cfg.designFlowRate != null) method = 'Flow/Zone';
        }
        if (!method) return; // nothing useful defined

        // Schedule
        let sched = cfg.scheduleName;
        if (sched && scheduleExists(sched)) {
            sched = sanitize(sched);
        } else if (sched && !scheduleExists(sched)) {
            // leave as-is; EnergyPlus will flag if invalid
        } else {
            sched = getAlwaysOn();
        }

        // Design flow parameters based on method
        let design = '';
        let perArea = '';
        let perPerson = '';
        let ach = '';

        if (method === 'Flow/Zone') {
            design = cfg.designFlowRate != null ? cfg.designFlowRate : '';
        } else if (method === 'Flow/Area') {
            perArea = cfg.flowPerArea != null ? cfg.flowPerArea : '';
        } else if (method === 'Flow/Person') {
            perPerson = cfg.flowPerPerson != null ? cfg.flowPerPerson : '';
        } else if (method === 'AirChanges/Hour') {
            ach = cfg.airChangesPerHour != null ? cfg.airChangesPerHour : '';
        }

        const ventType = cfg.ventilationType || 'Natural';
        const fanPress = cfg.fanPressure != null ? cfg.fanPressure : '';
        const fanEff =
            cfg.fanTotalEfficiency != null ? cfg.fanTotalEfficiency : '';

        const A = cfg.constantTermCoeff != null ? cfg.constantTermCoeff : 1.0;
        const B =
            cfg.temperatureTermCoeff != null ? cfg.temperatureTermCoeff : 0.0;
        const C =
            cfg.velocityTermCoeff != null ? cfg.velocityTermCoeff : 0.0;
        const D =
            cfg.velocitySquaredTermCoeff != null
                ? cfg.velocitySquaredTermCoeff
                : 0.0;

        const minTin = cfg.minIndoorTemp ?? '';
        const minTinSched = cfg.minIndoorTempScheduleName || '';
        const maxTin = cfg.maxIndoorTemp ?? '';
        const maxTinSched = cfg.maxIndoorTempScheduleName || '';
        const dT = cfg.deltaTemp ?? '';
        const dTSched = cfg.deltaTempScheduleName || '';
        const minTout = cfg.minOutdoorTemp ?? '';
        const minToutSched = cfg.minOutdoorTempScheduleName || '';
        const maxTout = cfg.maxOutdoorTemp ?? '';
        const maxToutSched = cfg.maxOutdoorTempScheduleName || '';
        const maxWS = cfg.maxWindSpeed ?? '';
        const densityBasis = cfg.densityBasis || 'Outdoor';

        const name = `${zn} Ventilation`;

        idf.push(`ZoneVentilation:DesignFlowRate,`);
        idf.push(`  ${sanitize(name)},         !- Name`);
        idf.push(`  ${zn},                    !- Zone or ZoneList or Space or SpaceList Name`);
        idf.push(`  ${sched},                 !- Schedule Name`);
        idf.push(`  ${method},                !- Design Flow Rate Calculation Method`);
        idf.push(`  ${design},                !- Design Flow Rate {m3/s}`);
        idf.push(`  ${perArea},               !- Flow Rate per Floor Area {m3/s-m2}`);
        idf.push(`  ${perPerson},             !- Flow Rate per Person {m3/s-person}`);
        idf.push(`  ${ach},                   !- Air Changes per Hour {1/hr}`);
        idf.push(`  ${ventType},              !- Ventilation Type`);
        idf.push(`  ${fanPress},              !- Fan Pressure Rise {Pa}`);
        idf.push(`  ${fanEff},                !- Fan Total Efficiency`);
        idf.push(`  ${A},                     !- Constant Term Coefficient`);
        idf.push(`  ${B},                     !- Temperature Term Coefficient`);
        idf.push(`  ${C},                     !- Velocity Term Coefficient`);
        idf.push(`  ${D},                     !- Velocity Squared Term Coefficient`);
        idf.push(`  ${minTin},                !- Minimum Indoor Temperature {C}`);
        idf.push(`  ${minTinSched},           !- Minimum Indoor Temperature Schedule Name`);
        idf.push(`  ${maxTin},                !- Maximum Indoor Temperature {C}`);
        idf.push(`  ${maxTinSched},           !- Maximum Indoor Temperature Schedule Name`);
        idf.push(`  ${dT},                    !- Delta Temperature {C}`);
        idf.push(`  ${dTSched},               !- Delta Temperature Schedule Name`);
        idf.push(`  ${minTout},               !- Minimum Outdoor Temperature {C}`);
        idf.push(`  ${minToutSched},          !- Minimum Outdoor Temperature Schedule Name`);
        idf.push(`  ${maxTout},               !- Maximum Outdoor Temperature {C}`);
        idf.push(`  ${maxToutSched},          !- Maximum Outdoor Temperature Schedule Name`);
        idf.push(`  ${maxWS},                 !- Maximum Wind Speed {m/s}`);
        idf.push(`  ${densityBasis};          !- Density Basis`);
        idf.push('');
    });
}

/**
 * OUTDOOR AIR DESIGN
 * Config: options.outdoorAir.designSpecs / spaceLists
 */
function emitDesignSpecificationOutdoorAir(idf, outdoorAir = {}, scheduleContext = {}) {
    const specs = Array.isArray(outdoorAir?.designSpecs)
        ? outdoorAir.designSpecs
        : [];
    if (!specs.length) return;

    const compact = scheduleContext.compact || {};
    const hasSchedule = (name) => {
        if (!name) return false;
        return !!compact[sanitize(name)];
    };

    specs.forEach((s) => {
        if (!s || !s.name) return;

        const name = sanitize(s.name);
        const method = s.method || 'Flow/Person';

        const fp = s.flowPerPerson != null ? s.flowPerPerson : '';
        const fa = s.flowPerArea != null ? s.flowPerArea : '';
        const fz = s.flowPerZone != null ? s.flowPerZone : '';
        const ach = s.airChangesPerHour != null ? s.airChangesPerHour : '';

        const sched =
            s.scheduleName && hasSchedule(s.scheduleName)
                ? sanitize(s.scheduleName)
                : (s.scheduleName || '');

        const propMin =
            s.proportionalMinOAFractionScheduleName &&
            hasSchedule(s.proportionalMinOAFractionScheduleName)
                ? sanitize(s.proportionalMinOAFractionScheduleName)
                : (s.proportionalMinOAFractionScheduleName || '');

        idf.push(`DesignSpecification:OutdoorAir,`);
        idf.push(`  ${name},                  !- Name`);
        idf.push(`  ${method},                !- Outdoor Air Method`);
        idf.push(`  ${fp},                    !- Outdoor Air Flow per Person {m3/s-person}`);
        idf.push(`  ${fa},                    !- Outdoor Air Flow per Zone Floor Area {m3/s-m2}`);
        idf.push(`  ${fz},                    !- Outdoor Air Flow per Zone {m3/s}`);
        idf.push(`  ${ach},                   !- Outdoor Air Flow Air Changes per Hour {1/hr}`);
        idf.push(`  ${sched},                 !- Outdoor Air Schedule Name`);
        idf.push(`  ${propMin};               !- Proportional Control Minimum Outdoor Air Flow Rate Schedule Name`);
        idf.push('');
    });
}

function emitDesignSpecificationOutdoorAirSpaceList(idf, outdoorAir = {}) {
    const lists = Array.isArray(outdoorAir?.spaceLists)
        ? outdoorAir.spaceLists
        : [];
    if (!lists.length) return;

    lists.forEach((sl) => {
        if (!sl || !sl.name || !Array.isArray(sl.items) || !sl.items.length) return;

        const name = sanitize(sl.name);
        idf.push(`DesignSpecification:OutdoorAir:SpaceList,`);
        idf.push(`  ${name},                  !- Name`);

        sl.items.forEach((it, idx) => {
            if (!it || !it.spaceName || !it.designSpecOutdoorAirObjectName) return;
            const space = sanitize(it.spaceName);
            const dsoa = sanitize(it.designSpecOutdoorAirObjectName);
            const isLast = idx === sl.items.length - 1;
            idf.push(`  ${space},               !- Space ${idx + 1} Name`);
            idf.push(`  ${dsoa}${isLast ? ';' : ','}               !- Space ${idx + 1} Design Specification Outdoor Air Object Name`);
        });

        idf.push('');
    });
}

/**
 * SHADING SURFACES
 * Config: shading.siteSurfaces / shading.zoneSurfaces
 */
function emitShadingSurfaces(idf, shading = {}, scheduleContext = {}) {
    if (!shading) return;

    const compact = scheduleContext.compact || {};
    const hasSchedule = (name) => {
        if (!name) return false;
        return !!compact[sanitize(name)];
    };

    const siteSurfaces = Array.isArray(shading.siteSurfaces)
        ? shading.siteSurfaces
        : [];
    siteSurfaces.forEach((s) => {
        if (!s || !s.name || !Array.isArray(s.vertices) || s.vertices.length < 3) return;
        const name = sanitize(s.name);
        const type =
            s.type === 'Building'
                ? 'Shading:Building:Detailed'
                : 'Shading:Site:Detailed';

        let sched = s.transmittanceScheduleName || '';
        if (sched && hasSchedule(sched)) {
            sched = sanitize(sched);
        }

        idf.push(`${type},`);
        idf.push(`  ${name},                  !- Name`);
        idf.push(`  ${sched || ''},           !- Transmittance Schedule Name`);
        idf.push(`  ,                         !- Solar Distribution (unused)`);

        idf.push(`  ${s.vertices.length},     !- Number of Vertices`);
        s.vertices.forEach((v, idx) => {
            if (
                !v ||
                !Number.isFinite(v.x) ||
                !Number.isFinite(v.y) ||
                !Number.isFinite(v.z)
            ) {
                return;
            }
            const suffix = idx === s.vertices.length - 1 ? ';' : ',';
            idf.push(
                `  ${v.x}, ${v.y}, ${v.z}${suffix}        !- Vertex ${idx + 1} {m}`
            );
        });
        idf.push('');
    });

    const zoneSurfaces = Array.isArray(shading.zoneSurfaces)
        ? shading.zoneSurfaces
        : [];
    zoneSurfaces.forEach((s) => {
        if (
            !s ||
            !s.name ||
            !s.baseSurfaceName ||
            !Array.isArray(s.vertices) ||
            s.vertices.length < 3
        ) {
            return;
        }
        const name = sanitize(s.name);
        const base = sanitize(s.baseSurfaceName);

        let sched = s.transmittanceScheduleName || '';
        if (sched && hasSchedule(sched)) {
            sched = sanitize(sched);
        }

        idf.push(`Shading:Zone:Detailed,`);
        idf.push(`  ${name},                  !- Name`);
        idf.push(`  ${sched || ''},           !- Transmittance Schedule Name`);
        idf.push(`  ${base},                  !- Base Surface Name`);
        idf.push(`  ${s.vertices.length},     !- Number of Vertices`);
        s.vertices.forEach((v, idx) => {
            if (
                !v ||
                !Number.isFinite(v.x) ||
                !Number.isFinite(v.y) ||
                !Number.isFinite(v.z)
            ) {
                return;
            }
            const suffix = idx === s.vertices.length - 1 ? ';' : ',';
            idf.push(
                `  ${v.x}, ${v.y}, ${v.z}${suffix}        !- Vertex ${idx + 1} {m}`
            );
        });
        idf.push('');
    });
}

/**
 * SHADING REFLECTANCE
 * Config: shading.reflectance[]
 */
function emitShadingReflectance(idf, shading = {}) {
    const items = Array.isArray(shading.reflectance)
        ? shading.reflectance
        : [];
    items.forEach((r) => {
        if (!r || !r.shadingSurfaceName) return;
        const sName = sanitize(r.shadingSurfaceName);

        idf.push(`ShadingProperty:Reflectance,`);
        idf.push(`  ${sName},                 !- Name`);
        idf.push(`  ${sName},                 !- Shading Surface Name`);
        idf.push(
            `  ${r.solarReflectance != null ? r.solarReflectance : ''}, !- Solar Reflectance`
        );
        idf.push(
            `  ${
                r.visibleReflectance != null ? r.visibleReflectance : ''
            }, !- Visible Reflectance`
        );
        idf.push(
            `  ${
                r.infraredHemisphericalEmissivity != null
                    ? r.infraredHemisphericalEmissivity
                    : ''
            }, !- Infrared Hemispherical Emissivity`
        );
        idf.push(
            `  ${
                r.infraredTransmittance != null
                    ? r.infraredTransmittance
                    : ''
            }; !- Infrared Transmittance`
        );
        idf.push('');
    });
}

/**
 * WINDOW SHADING CONTROL
 * Config: shading.windowShadingControls[]
 * Thin mapping; assumes fenestration surfaces exist/are named correctly.
 */
function emitWindowShadingControls(idf, shading = {}, scheduleContext = {}) {
    const compact = scheduleContext.compact || {};
    const hasSchedule = (name) => {
        if (!name) return false;
        return !!compact[sanitize(name)];
    };

    const ctrls = Array.isArray(shading.windowShadingControls)
        ? shading.windowShadingControls
        : [];

    ctrls.forEach((c) => {
        if (
            !c ||
            !c.name ||
            !c.shadingType ||
            !c.controlType ||
            !Array.isArray(c.fenestrationSurfaceNames) ||
            !c.fenestrationSurfaceNames.length
        ) {
            return;
        }

        const name = sanitize(c.name);
        const shadingType = c.shadingType;
        const controlType = c.controlType;

        let sched = c.scheduleName || '';
        if (sched && hasSchedule(sched)) {
            sched = sanitize(sched);
        }

        const set1 =
            c.setpoint1 != null && isFinite(c.setpoint1)
                ? c.setpoint1
                : '';
        const set2 =
            c.setpoint2 != null && isFinite(c.setpoint2)
                ? c.setpoint2
                : '';

        const glareActive =
            c.glareControlIsActive === true ? 'Yes' : 'No';

        const multiType =
            c.multipleSurfaceControlType ||
            (c.fenestrationSurfaceNames.length > 1 ? 'Group' : '');

        idf.push(`WindowShadingControl,`);
        idf.push(`  ${name},                  !- Name`);
        idf.push(`  ${shadingType},           !- Shading Type`);
        idf.push(`  ${controlType},           !- Shading Control Type`);
        idf.push(`  ${sched},                 !- Schedule Name`);
        idf.push(`  ${set1},                  !- Setpoint 1`);
        idf.push(`  ${set2},                  !- Setpoint 2`);
        idf.push(
            `  ${sched ? 'Yes' : 'No'},      !- Shading Control Is Scheduled`
        );
        idf.push(
            `  ${glareActive},              !- Glare Control Is Active`
        );
        idf.push(
            `  ,                           !- Shading Device Material or Construction Name`
        );
        idf.push(
            `  ,                           !- Type of Slat Angle Control for Blinds`
        );
        idf.push(
            `  ,                           !- Slat Angle Schedule Name`
        );
        idf.push(`  ,                           !- Setpoint 3`);
        idf.push(`  ,                           !- Setpoint 4`);
        idf.push(
            `  ${multiType},               !- Multiple Surface Control Type`
        );

        const names = c.fenestrationSurfaceNames.map((n) => sanitize(n));
        names.forEach((fn, idx) => {
            const suffix = idx === names.length - 1 ? ';' : ',';
            idf.push(
                `  ${fn}${suffix}               !- Fenestration Surface ${idx + 1} Name`
            );
        });

        idf.push('');
    });
}

/**
 * DAYLIGHTING & OUTPUTS
 */
/**
 * SIZING:ZONE
 * Config: options.sizing.zones: [{ zoneName, ...Sizing:Zone fields... }]
 * If no config, emit robust defaults per zone.
 */
function emitSizingZone(idf, zones, sizingCfg = {}) {
    const znList = zones && zones.length ? zones : [{ name: 'Zone_1' }];
    const cfgByZone = new Map();

    if (Array.isArray(sizingCfg.zones)) {
        sizingCfg.zones.forEach((z) => {
            if (!z || !z.zoneName) return;
            cfgByZone.set(sanitize(z.zoneName), z);
        });
    }

    znList.forEach((z, idx) => {
        const zn = sanitize(z.name || `Zone_${idx + 1}`);
        const c = cfgByZone.get(zn) || {};

        // Cooling supply air temperature / method
        const coolTMethod =
            c.zoneCoolingDesignSupplyAirTemperatureInputMethod ||
            (c.zoneCoolingDesignSupplyAirTemperatureDifference != null
                ? 'TemperatureDifference'
                : 'SupplyAirTemperature');
        const coolT =
            c.zoneCoolingDesignSupplyAirTemperature != null
                ? c.zoneCoolingDesignSupplyAirTemperature
                : 14.0;
        const coolDT =
            c.zoneCoolingDesignSupplyAirTemperatureDifference != null
                ? c.zoneCoolingDesignSupplyAirTemperatureDifference
                : '';

        // Heating supply air temperature / method
        const heatTMethod =
            c.zoneHeatingDesignSupplyAirTemperatureInputMethod ||
            (c.zoneHeatingDesignSupplyAirTemperatureDifference != null
                ? 'TemperatureDifference'
                : 'SupplyAirTemperature');
        const heatT =
            c.zoneHeatingDesignSupplyAirTemperature != null
                ? c.zoneHeatingDesignSupplyAirTemperature
                : 40.0;
        const heatDT =
            c.zoneHeatingDesignSupplyAirTemperatureDifference != null
                ? c.zoneHeatingDesignSupplyAirTemperatureDifference
                : '';

        const coolHum =
            c.zoneCoolingDesignSupplyAirHumidityRatio != null
                ? c.zoneCoolingDesignSupplyAirHumidityRatio
                : 0.009;
        const heatHum =
            c.zoneHeatingDesignSupplyAirHumidityRatio != null
                ? c.zoneHeatingDesignSupplyAirHumidityRatio
                : 0.004;

        const dsoaName = c.designSpecOutdoorAirName
            ? sanitize(c.designSpecOutdoorAirName)
            : '';

        const heatSF =
            c.zoneHeatingSizingFactor != null ? c.zoneHeatingSizingFactor : 1.0;
        const coolSF =
            c.zoneCoolingSizingFactor != null ? c.zoneCoolingSizingFactor : 1.0;

        const clgFlowMethod =
            c.coolingDesignAirFlowMethod || 'DesignDay';
        const clgFlow =
            c.coolingDesignAirFlowRate != null
                ? c.coolingDesignAirFlowRate
                : '';
        const clgMinPerArea =
            c.coolingMinimumAirFlowPerZoneFloorArea != null
                ? c.coolingMinimumAirFlowPerZoneFloorArea
                : '';
        const clgMinFlow =
            c.coolingMinimumAirFlow != null
                ? c.coolingMinimumAirFlow
                : '';
        const clgMinFrac =
            c.coolingMinimumAirFlowFraction != null
                ? c.coolingMinimumAirFlowFraction
                : '';

        const htgFlowMethod =
            c.heatingDesignAirFlowMethod || 'DesignDay';
        const htgFlow =
            c.heatingDesignAirFlowRate != null
                ? c.heatingDesignAirFlowRate
                : '';
        const htgMaxPerArea =
            c.heatingMaximumAirFlowPerZoneFloorArea != null
                ? c.heatingMaximumAirFlowPerZoneFloorArea
                : '';
        const htgMaxFlow =
            c.heatingMaximumAirFlow != null
                ? c.heatingMaximumAirFlow
                : '';
        const htgMaxFrac =
            c.heatingMaximumAirFlowFraction != null
                ? c.heatingMaximumAirFlowFraction
                : '';

        const dzadName = c.designSpecificationZoneAirDistributionObjectName
            ? sanitize(c.designSpecificationZoneAirDistributionObjectName)
            : '';

        const doasFlag =
            c.accountForDedicatedOutdoorAirSystem === 'Yes' ? 'Yes' : 'No';
        const doasCtrl =
            c.dedicatedOutdoorAirSystemControlStrategy || '';
        const doasLow =
            c.dedicatedOutdoorAirLowTemperatureSetpointForDesign != null
                ? c.dedicatedOutdoorAirLowTemperatureSetpointForDesign
                : '';
        const doasHigh =
            c.dedicatedOutdoorAirHighTemperatureSetpointForDesign != null
                ? c.dedicatedOutdoorAirHighTemperatureSetpointForDesign
                : '';

        const loadSizingMethod =
            c.zoneLoadSizingMethod ||
            'Sensible Load Only No Latent Load';

        const latCoolHRMethod =
            c.zoneLatentCoolingDesignSupplyAirHumidityRatioInputMethod || '';
        const latCoolHR =
            c.zoneDehumidificationDesignSupplyAirHumidityRatio != null
                ? c.zoneDehumidificationDesignSupplyAirHumidityRatio
                : '';
        const latCoolHRDiff =
            c.zoneCoolingDesignSupplyAirHumidityRatioDifference != null
                ? c.zoneCoolingDesignSupplyAirHumidityRatioDifference
                : '';

        const latHeatHRMethod =
            c.zoneLatentHeatingDesignSupplyAirHumidityRatioInputMethod || '';
        const latHeatHR =
            c.zoneHumidificationDesignSupplyAirHumidityRatio != null
                ? c.zoneHumidificationDesignSupplyAirHumidityRatio
                : '';
        const latHeatHRDiff =
            c.zoneHeatingDesignSupplyAirHumidityRatioDifference != null
                ? c.zoneHeatingDesignSupplyAirHumidityRatioDifference
                : '';

        const dehumSP =
            c.zoneHumidistatDehumidificationSetPointScheduleName || '';
        const humSP =
            c.zoneHumidistatHumidificationSetPointScheduleName || '';

        const spaceSum =
            c.typeOfSpaceSumToUse || 'Coincident';

        idf.push(`Sizing:Zone,`);
        idf.push(`  ${zn},                    !- Zone or ZoneList Name`);
        idf.push(`  ${coolTMethod},           !- Zone Cooling Design Supply Air Temperature Input Method`);
        idf.push(`  ${coolT},                 !- Zone Cooling Design Supply Air Temperature {C}`);
        idf.push(`  ${coolDT},                !- Zone Cooling Design Supply Air Temperature Difference {deltaC}`);
        idf.push(`  ${heatTMethod},           !- Zone Heating Design Supply Air Temperature Input Method`);
        idf.push(`  ${heatT},                 !- Zone Heating Design Supply Air Temperature {C}`);
        idf.push(`  ${heatDT},                !- Zone Heating Design Supply Air Temperature Difference {deltaC}`);
        idf.push(`  ${coolHum},               !- Zone Cooling Design Supply Air Humidity Ratio {kgWater/kgDryAir}`);
        idf.push(`  ${heatHum},               !- Zone Heating Design Supply Air Humidity Ratio {kgWater/kgDryAir}`);
        idf.push(`  ${dsoaName},              !- Design Specification Outdoor Air Object Name`);
        idf.push(`  ${heatSF},                !- Zone Heating Sizing Factor`);
        idf.push(`  ${coolSF},                !- Zone Cooling Sizing Factor`);
        idf.push(`  ${clgFlowMethod},         !- Cooling Design Air Flow Method`);
        idf.push(`  ${clgFlow},               !- Cooling Design Air Flow Rate {m3/s}`);
        idf.push(`  ${clgMinPerArea},         !- Cooling Minimum Air Flow per Zone Floor Area {m3/s-m2}`);
        idf.push(`  ${clgMinFlow},            !- Cooling Minimum Air Flow {m3/s}`);
        idf.push(`  ${clgMinFrac},            !- Cooling Minimum Air Flow Fraction`);
        idf.push(`  ${htgFlowMethod},         !- Heating Design Air Flow Method`);
        idf.push(`  ${htgFlow},               !- Heating Design Air Flow Rate {m3/s}`);
        idf.push(`  ${htgMaxPerArea},         !- Heating Maximum Air Flow per Zone Floor Area {m3/s-m2}`);
        idf.push(`  ${htgMaxFlow},            !- Heating Maximum Air Flow {m3/s}`);
        idf.push(`  ${htgMaxFrac},            !- Heating Maximum Air Flow Fraction`);
        idf.push(`  ${dzadName},              !- Design Specification Zone Air Distribution Object Name`);
        idf.push(`  ${doasFlag},              !- Account for Dedicated Outdoor Air System`);
        idf.push(`  ${doasCtrl},              !- Dedicated Outdoor Air System Control Strategy`);
        idf.push(`  ${doasLow},               !- Dedicated Outdoor Air Low Setpoint for Design {C}`);
        idf.push(`  ${doasHigh},              !- Dedicated Outdoor Air High Setpoint for Design {C}`);
        idf.push(`  ${loadSizingMethod},      !- Zone Load Sizing Method`);
        idf.push(`  ${latCoolHRMethod},       !- Zone Latent Cooling Design Supply Air Humidity Ratio Input Method`);
        idf.push(`  ${latCoolHR},             !- Zone Dehumidification Design Supply Air Humidity Ratio {kgWater/kgDryAir}`);
        idf.push(`  ${latCoolHRDiff},         !- Zone Cooling Design Supply Air Humidity Ratio Difference {kgWater/kgDryAir}`);
        idf.push(`  ${latHeatHRMethod},       !- Zone Latent Heating Design Supply Air Humidity Ratio Input Method`);
        idf.push(`  ${latHeatHR},             !- Zone Humidification Design Supply Air Humidity Ratio {kgWater/kgDryAir}`);
        idf.push(`  ${latHeatHRDiff},         !- Zone Heating Design Supply Air Humidity Ratio Difference {kgWater/kgDryAir}`);
        idf.push(`  ${dehumSP},               !- Zone Humidistat Dehumidification Set Point Schedule Name`);
        idf.push(`  ${humSP},                 !- Zone Humidistat Humidification Set Point Schedule Name`);
        idf.push(`  ${spaceSum};              !- Type of Space Sum to Use`);
        idf.push('');
    });
}

/**
 * SIZING:SYSTEM
 * Config: options.sizing.systems: [{ airLoopName, ...Sizing:System fields... }]
 * Only emitted when provided; keeps minimal models clean.
 */
function emitSizingSystem(idf, sizingCfg = {}) {
    const systems = Array.isArray(sizingCfg.systems)
        ? sizingCfg.systems
        : [];

    systems.forEach((s) => {
        if (!s || !s.airLoopName) return;
        const name = sanitize(s.airLoopName);

        const loadType = s.typeOfLoadToSizeOn || 'Sensible';
        const doasOA = s.designOutdoorAirFlowRate != null
            ? s.designOutdoorAirFlowRate
            : 'autosize';

        const heatFlowRatio =
            s.centralHeatingMaximumSystemAirFlowRatio != null
                ? s.centralHeatingMaximumSystemAirFlowRatio
                : '';

        const preheatT =
            s.preheatDesignTemperature != null
                ? s.preheatDesignTemperature
                : 4.5;
        const preheatW =
            s.preheatDesignHumidityRatio != null
                ? s.preheatDesignHumidityRatio
                : 0.008;
        const precoolT =
            s.precoolDesignTemperature != null
                ? s.precoolDesignTemperature
                : 11.0;
        const precoolW =
            s.precoolDesignHumidityRatio != null
                ? s.precoolDesignHumidityRatio
                : 0.008;

        const coolSAT =
            s.centralCoolingDesignSupplyAirTemperature != null
                ? s.centralCoolingDesignSupplyAirTemperature
                : 12.8;
        const heatSAT =
            s.centralHeatingDesignSupplyAirTemperature != null
                ? s.centralHeatingDesignSupplyAirTemperature
                : 16.7;

        const zoneSumType =
            s.typeOfZoneSumToUse || s.sizingOption || 'noncoincident';

        const oaClg100 = s.do100PercentOutdoorAirInCooling === 'Yes'
            ? 'Yes'
            : 'No';
        const oaHtg100 = s.do100PercentOutdoorAirInHeating === 'Yes'
            ? 'Yes'
            : 'No';

        const coolSATw =
            s.centralCoolingDesignSupplyAirHumidityRatio != null
                ? s.centralCoolingDesignSupplyAirHumidityRatio
                : 0.008;
        const heatSATw =
            s.centralHeatingDesignSupplyAirHumidityRatio != null
                ? s.centralHeatingDesignSupplyAirHumidityRatio
                : 0.008;

        const clgFlowMethod =
            s.coolingSupplyAirFlowRateMethod || 'DesignDay';
        const clgFlow =
            s.coolingSupplyAirFlowRate != null
                ? s.coolingSupplyAirFlowRate
                : 0;
        const clgPerArea =
            s.coolingSupplyAirFlowRatePerFloorArea || '';
        const clgFracAuto =
            s.coolingFractionOfAutosizedCoolingDesignSupplyAirFlowRate || '';
        const clgPerCap =
            s.coolingSupplyAirFlowRatePerUnitCoolingCapacity || '';

        const htgFlowMethod =
            s.heatingSupplyAirFlowRateMethod || 'DesignDay';
        const htgFlow =
            s.heatingSupplyAirFlowRate != null
                ? s.heatingSupplyAirFlowRate
                : 0;
        const htgPerArea =
            s.heatingSupplyAirFlowRatePerFloorArea || '';
        const htgFracHeat =
            s.heatingFractionOfAutosizedHeatingDesignSupplyAirFlowRate || '';
        const htgFracCool =
            s.heatingFractionOfAutosizedCoolingDesignSupplyAirFlowRate || '';
        const htgPerCap =
            s.heatingSupplyAirFlowRatePerUnitHeatingCapacity || '';

        const sysOAMethod =
            s.systemOutdoorAirMethod || 'ZoneSum';
        const zoneMaxOAFraction =
            s.zoneMaximumOutdoorAirFraction != null
                ? s.zoneMaximumOutdoorAirFraction
                : 1.0;

        const clgCapMethod =
            s.coolingDesignCapacityMethod || 'CoolingDesignCapacity';
        const clgCap = s.coolingDesignCapacity || 'autosize';
        const clgCapPerArea =
            s.coolingDesignCapacityPerFloorArea || '';
        const clgCapFracAuto =
            s.fractionOfAutosizedCoolingDesignCapacity || '';

        const htgCapMethod =
            s.heatingDesignCapacityMethod || 'HeatingDesignCapacity';
        const htgCap = s.heatingDesignCapacity || 'autosize';
        const htgCapPerArea =
            s.heatingDesignCapacityPerFloorArea || '';
        const htgCapFracAuto =
            s.fractionOfAutosizedHeatingDesignCapacity || '';

        const coolCtrl =
            s.centralCoolingCapacityControlMethod || 'VAV';
        const diversity =
            s.occupantDiversity != null
                ? s.occupantDiversity
                : 'autosize';

        idf.push(`Sizing:System,`);
        idf.push(`  ${name},                  !- AirLoop Name`);
        idf.push(`  ${loadType},              !- Type of Load to Size On`);
        idf.push(`  ${doasOA},                !- Design Outdoor Air Flow Rate {m3/s}`);
        idf.push(`  ${heatFlowRatio},         !- Central Heating Maximum System Air Flow Ratio`);
        idf.push(`  ${preheatT},              !- Preheat Design Temperature {C}`);
        idf.push(`  ${preheatW},              !- Preheat Design Humidity Ratio {kgWater/kgDryAir}`);
        idf.push(`  ${precoolT},              !- Precool Design Temperature {C}`);
        idf.push(`  ${precoolW},              !- Precool Design Humidity Ratio {kgWater/kgDryAir}`);
        idf.push(`  ${coolSAT},               !- Central Cooling Design Supply Air Temperature {C}`);
        idf.push(`  ${heatSAT},               !- Central Heating Design Supply Air Temperature {C}`);
        idf.push(`  ${zoneSumType},           !- Type of Zone Sum to Use`);
        idf.push(`  ${oaClg100},              !- 100% Outdoor Air in Cooling`);
        idf.push(`  ${oaHtg100},              !- 100% Outdoor Air in Heating`);
        idf.push(`  ${coolSATw},              !- Central Cooling Design Supply Air Humidity Ratio {kgWater/kgDryAir}`);
        idf.push(`  ${heatSATw},              !- Central Heating Design Supply Air Humidity Ratio {kgWater/kgDryAir}`);
        idf.push(`  ${clgFlowMethod},         !- Cooling Supply Air Flow Rate Method`);
        idf.push(`  ${clgFlow},               !- Cooling Supply Air Flow Rate {m3/s}`);
        idf.push(`  ${clgPerArea},            !- Cooling Supply Air Flow Rate Per Floor Area {m3/s-m2}`);
        idf.push(`  ${clgFracAuto},           !- Cooling Fraction of Autosized Cooling Supply Air Flow Rate`);
        idf.push(`  ${clgPerCap},             !- Cooling Supply Air Flow Rate Per Unit Cooling Capacity {m3/s-W}`);
        idf.push(`  ${htgFlowMethod},         !- Heating Supply Air Flow Rate Method`);
        idf.push(`  ${htgFlow},               !- Heating Supply Air Flow Rate {m3/s}`);
        idf.push(`  ${htgPerArea},            !- Heating Supply Air Flow Rate Per Floor Area {m3/s-m2}`);
        idf.push(`  ${htgFracHeat},           !- Heating Fraction of Autosized Heating Supply Air Flow Rate`);
        idf.push(`  ${htgFracCool},           !- Heating Fraction of Autosized Cooling Supply Air Flow Rate`);
        idf.push(`  ${htgPerCap},             !- Heating Supply Air Flow Rate Per Unit Heating Capacity {m3/s-W}`);
        idf.push(`  ${sysOAMethod},           !- System Outdoor Air Method`);
        idf.push(`  ${zoneMaxOAFraction},     !- Zone Maximum Outdoor Air Fraction`);
        idf.push(`  ${clgCapMethod},          !- Cooling Design Capacity Method`);
        idf.push(`  ${clgCap},                !- Cooling Design Capacity {W}`);
        idf.push(`  ${clgCapPerArea},         !- Cooling Design Capacity Per Floor Area {W/m2}`);
        idf.push(`  ${clgCapFracAuto},        !- Fraction of Autosized Cooling Design Capacity`);
        idf.push(`  ${htgCapMethod},          !- Heating Design Capacity Method`);
        idf.push(`  ${htgCap},                !- Heating Design Capacity {W}`);
        idf.push(`  ${htgCapPerArea},         !- Heating Design Capacity Per Floor Area {W/m2}`);
        idf.push(`  ${htgCapFracAuto},        !- Fraction of Autosized Heating Design Capacity`);
        idf.push(`  ${coolCtrl},              !- Central Cooling Capacity Control Method`);
        idf.push(`  ${diversity};             !- Occupant Diversity`);
        idf.push('');
    });
}

/**
 * SIZING:PLANT
 * Config: options.sizing.plants: [{ plantLoopName, designLoopExitTemperature, loopDesignTemperatureDifference }]
 * Minimal support; only emitted when configured.
 */
function emitSizingPlant(idf, sizingCfg = {}) {
    const plants = Array.isArray(sizingCfg.plants)
        ? sizingCfg.plants
        : [];

    plants.forEach((p) => {
        if (!p || !p.plantLoopName) return;
        const name = sanitize(p.plantLoopName);
        const loopType = p.loopType || ''; // optional / informational
        const exitT =
            p.designLoopExitTemperature != null
                ? p.designLoopExitTemperature
                : '';
        const dT =
            p.loopDesignTemperatureDifference != null
                ? p.loopDesignTemperatureDifference
                : '';

        idf.push(`Sizing:Plant,`);
        idf.push(`  ${name},                  !- Plant or Condenser Loop Name`);
        idf.push(`  ${loopType},              !- Loop Type`);
        idf.push(`  ${exitT},                 !- Design Loop Exit Temperature {C}`);
        idf.push(`  ${dT};                    !- Loop Design Temperature Difference {deltaC}`);
        idf.push('');
    });
}

function emitDaylighting(idf, zones, daylighting = {}, scheduleContext = {}) {
    if (!daylighting) return;

    const znIndex = new Map();
    const znList = zones && zones.length ? zones : [{ name: 'Zone_1' }];
    znList.forEach((z, idx) => {
        const name = sanitize(z.name || `Zone_${idx + 1}`);
        znIndex.set(name, name);
    });

    const compact = scheduleContext.compact || {};
    const scheduleExists = (name) => {
        if (!name) return false;
        return !!compact[sanitize(name)];
    };

    emitDaylightingControlsAndRefPoints(idf, znIndex, daylighting, scheduleExists);
    emitIlluminanceMaps(idf, znIndex, daylighting);
    emitDaylightingOutputVariables(idf, daylighting);
    // emitDaylightingDevices can be added later in a backward-compatible way.
}

/**
 * Advanced Daylighting Controls + Reference Points
 * Primary schema: daylighting.zones[]
 * Backward compatible with legacy daylighting.controls format.
 */
function emitDaylightingControlsAndRefPoints(idf, znIndex, daylighting, scheduleExists) {
    const zonesCfg = Array.isArray(daylighting.zones) ? daylighting.zones : [];

    if (zonesCfg.length) {
        zonesCfg.forEach((cfg) => {
            if (!cfg || !cfg.zoneName) return;
            const zn = sanitize(cfg.zoneName);
            if (!znIndex.has(zn)) return;

            const enabled = cfg.enabled !== false;
            const refs = Array.isArray(cfg.referencePoints)
                ? cfg.referencePoints.filter((rp) =>
                    rp &&
                    Number.isFinite(rp.x) &&
                    Number.isFinite(rp.y) &&
                    Number.isFinite(rp.z) &&
                    Number.isFinite(rp.setpoint)
                )
                : [];

            if (!enabled || !refs.length) return;

            const rpList = refs.slice(0, 2);
            const ctrlName = sanitize(cfg.controlName || `DL_${zn}`);
            const controlType =
                cfg.controlType === 'Stepped'
                    ? 'Stepped'
                    : cfg.controlType === 'ContinuousOff'
                    ? 'ContinuousOff'
                    : 'Continuous';

            let avail = cfg.availabilityScheduleName || '';
            if (avail && scheduleExists(avail)) {
                avail = sanitize(avail);
            } else if (avail && !scheduleExists(avail)) {
                // Keep as-is; E+ will warn if invalid
            } else {
                avail = '';
            }

            const minIn = cfg.minInputPowerFraction != null ? cfg.minInputPowerFraction : 0.2;
            const minOut = cfg.minLightOutputFraction != null ? cfg.minLightOutputFraction : 0.2;

            let frac1 = 1.0;
            let frac2 = 0.0;
            if (Array.isArray(cfg.fractions)) {
                if (cfg.fractions.length >= 1 && typeof cfg.fractions[0] === 'number') {
                    frac1 = cfg.fractions[0];
                }
                if (cfg.fractions.length >= 2 && typeof cfg.fractions[1] === 'number') {
                    frac2 = cfg.fractions[1];
                }
            } else if (typeof cfg.fractions === 'number') {
                frac1 = cfg.fractions;
            } else if (rpList.length === 2) {
                frac1 = 0.5;
                frac2 = 0.5;
            }

            // Emit Daylighting:ReferencePoint(s)
            const rpNames = [];
            rpList.forEach((rp, i) => {
                const rpName = sanitize(
                    rp.name || `RP_${zn}_${i + 1}`
                );
                rpNames.push({ name: rpName, setpoint: rp.setpoint });
                idf.push(`Daylighting:ReferencePoint,`);
                idf.push(`  ${rpName},              !- Name`);
                idf.push(`  ${zn},                  !- Zone Name`);
                idf.push(`  ${rp.x},                !- X-Coordinate of Reference Point {m}`);
                idf.push(`  ${rp.y},                !- Y-Coordinate of Reference Point {m}`);
                idf.push(`  ${rp.z};                !- Z-Coordinate of Reference Point {m}`);
                idf.push('');
            });

            // Emit Daylighting:Controls
            idf.push(`Daylighting:Controls,`);
            idf.push(`  ${ctrlName},             !- Name`);
            idf.push(`  ${zn},                  !- Zone Name`);
            idf.push(`  ${controlType},          !- Daylighting System Control Type`);
            idf.push(`  ${avail},               !- Availability Schedule Name`);
            idf.push(`  0.0,                    !- Minimum Input Power Fraction for Continuous Dimming Control`);
            idf.push(`  0.0,                    !- Minimum Light Output Fraction for Continuous Dimming Control`);
            idf.push(`  ${minIn},               !- Minimum Input Power Fraction for Continuous OFF Control`);
            idf.push(`  ${minOut},              !- Minimum Light Output Fraction for Continuous OFF Control`);
            idf.push(`  ${rpNames.length},      !- Number of Daylighting Reference Points`);

            if (rpNames.length >= 1) {
                idf.push(`  ${rpNames[0].name},    !- Daylighting Reference Point 1 Name`);
                idf.push(`  ${rpNames[0].setpoint},!- Fraction of Zone Lights Controlled by Reference Point 1`);
                idf.push(`  ${frac1},              !- Illuminance Setpoint at Reference Point 1 {lux}`);
            }

            if (rpNames.length >= 2) {
                idf.push(`  ${rpNames[1].name},    !- Daylighting Reference Point 2 Name`);
                idf.push(`  ${rpNames[1].setpoint},!- Fraction of Zone Lights Controlled by Reference Point 2`);
                idf.push(`  ${frac2};              !- Illuminance Setpoint at Reference Point 2 {lux}`);
            } else {
                idf.push(`  ,                      !- Daylighting Reference Point 2 Name`);
                idf.push(`  ,                      !- Fraction of Zone Lights Controlled by Reference Point 2`);
                idf.push(`  ;                      !- Illuminance Setpoint at Reference Point 2 {lux}`);
            }

            idf.push('');
        });

        return;
    }

    // Backward-compatible path: legacy daylighting.controls
    const legacyControls = Array.isArray(daylighting.controls)
        ? daylighting.controls
        : [];

    legacyControls.forEach((c, idx) => {
        if (!c || !c.zoneName) return;
        if (c.enabled === false) return;

        const zn = sanitize(c.zoneName);
        if (!znIndex.has(zn)) return;

        const refPoints = Array.isArray(c.refPoints)
            ? c.refPoints.filter((rp) =>
                rp &&
                Number.isFinite(rp.x) &&
                Number.isFinite(rp.y) &&
                Number.isFinite(rp.z)
            ).slice(0, 2)
            : [];
        if (!refPoints.length || !Number.isFinite(c.setpoint)) return;

        const ctrlType =
            c.type === 'Stepped'
                ? 'Stepped'
                : c.type === 'ContinuousOff'
                ? 'ContinuousOff'
                : 'Continuous';

        const frac =
            typeof c.fraction === 'number' && c.fraction > 0
                ? c.fraction
                : 1.0;

        const rp1 = refPoints[0];
        const rp2 = refPoints[1];

        const ctrlName = `DL_${zn}_${idx + 1}`;
        const rp1Name = `RP_${zn}_${idx + 1}_1`;
        const rp2Name = rp2 ? `RP_${zn}_${idx + 1}_2` : null;

        // Reference Point 1
        idf.push(`Daylighting:ReferencePoint,`);
        idf.push(`  ${rp1Name},               !- Name`);
        idf.push(`  ${zn},                    !- Zone Name`);
        idf.push(`  ${rp1.x},                 !- X-Coordinate {m}`);
        idf.push(`  ${rp1.y},                 !- Y-Coordinate {m}`);
        idf.push(`  ${rp1.z};                 !- Z-Coordinate {m}`);
        idf.push('');

        // Reference Point 2 (optional)
        if (rp2) {
            idf.push(`Daylighting:ReferencePoint,`);
            idf.push(`  ${rp2Name},             !- Name`);
            idf.push(`  ${zn},                  !- Zone Name`);
            idf.push(`  ${rp2.x},               !- X-Coordinate {m}`);
            idf.push(`  ${rp2.y},               !- Y-Coordinate {m}`);
            idf.push(`  ${rp2.z};               !- Z-Coordinate {m}`);
            idf.push('');
        }

        // Controls
        idf.push(`Daylighting:Controls,`);
        idf.push(`  ${ctrlName},              !- Name`);
        idf.push(`  ${zn},                    !- Zone Name`);
        idf.push(`  ${ctrlType},              !- Daylighting System Control Type`);
        idf.push(`  ,                         !- Availability Schedule Name`);
        idf.push(`  0.2,                      !- Minimum Input Power Fraction for Continuous Dimming Control`);
        idf.push(`  0.2,                      !- Minimum Light Output Fraction for Continuous Dimming Control`);
        idf.push(`  0.2,                      !- Minimum Input Power Fraction for Continuous OFF Control`);
        idf.push(`  0.2,                      !- Minimum Light Output Fraction for Continuous OFF Control`);
        idf.push(`  ${rp2 ? 2 : 1},           !- Number of Daylighting Reference Points`);
        idf.push(`  ${rp1Name},               !- Daylighting Reference Point 1 Name`);
        idf.push(`  ${frac},                  !- Fraction of Zone Lights Controlled by Reference Point 1`);
        idf.push(`  ${c.setpoint},            !- Illuminance Setpoint at Reference Point 1 {lux}`);

        if (rp2) {
            idf.push(`  ${rp2Name},             !- Daylighting Reference Point 2 Name`);
            idf.push(`  ${1 - frac},            !- Fraction of Zone Lights Controlled by Reference Point 2`);
            idf.push(`  ${c.setpoint};          !- Illuminance Setpoint at Reference Point 2 {lux}`);
        } else {
            idf.push(`  ,                       !- Daylighting Reference Point 2 Name`);
            idf.push(`  ,                       !- Fraction of Zone Lights Controlled by Reference Point 2`);
            idf.push(`  ;                       !- Illuminance Setpoint at Reference Point 2 {lux}`);
        }

        idf.push('');
    });
}

/**
 * Illuminance maps from daylighting.outputs and daylighting.zones[*].illuminanceMaps
 */
function emitIlluminanceMaps(idf, znIndex, daylighting) {
    const outputs = daylighting.outputs || {};
    const globalMaps = Array.isArray(outputs.illuminanceMaps)
        ? outputs.illuminanceMaps
        : [];

    const zoneMaps = [];
    if (Array.isArray(daylighting.zones)) {
        daylighting.zones.forEach((z) => {
            if (!z || !z.zoneName || !Array.isArray(z.illuminanceMaps)) return;
            const zn = sanitize(z.zoneName);
            if (!znIndex.has(zn)) return;
            z.illuminanceMaps.forEach((m) => {
                if (!m) return;
                zoneMaps.push({ ...m, zoneName: zn });
            });
        });
    }

    const allMaps = [
        ...globalMaps,
        ...zoneMaps,
    ];

    allMaps.forEach((m) => {
        if (
            !m ||
            !m.zoneName ||
            !znIndex.has(sanitize(m.zoneName)) ||
            !Number.isFinite(m.xOrigin) ||
            !Number.isFinite(m.yOrigin) ||
            !Number.isFinite(m.zHeight) ||
            !Number.isFinite(m.xNumPoints) ||
            !Number.isFinite(m.xSpacing) ||
            !Number.isFinite(m.yNumPoints) ||
            !Number.isFinite(m.ySpacing)
        ) {
            return;
        }

        const zn = sanitize(m.zoneName);
        const name = sanitize(m.name || `IllMap_${zn}`);

        idf.push(`Output:IlluminanceMap,`);
        idf.push(`  ${name},                  !- Name`);
        idf.push(`  ${zn},                    !- Zone Name`);
        idf.push(`  ${m.xOrigin},             !- X-Origin {m}`);
        idf.push(`  ${m.yOrigin},             !- Y-Origin {m}`);
        idf.push(`  ${m.zHeight},             !- Z-Height {m}`);
        idf.push(`  ${m.xNumPoints},          !- Number of X-Direction Grid Points`);
        idf.push(`  ${m.xSpacing},            !- X-Direction Grid Spacing {m}`);
        idf.push(`  ${m.yNumPoints},          !- Number of Y-Direction Grid Points`);
        idf.push(`  ${m.ySpacing};            !- Y-Direction Grid Spacing {m}`);
        idf.push('');
    });
}

/**
 * Output:Variable for daylighting
 */
function emitDaylightingOutputVariables(idf, daylighting) {
    const outputs = daylighting.outputs || {};
    const vars = Array.isArray(outputs.variables) ? outputs.variables : [];

    vars.forEach((v) => {
        if (!v || !v.key || !v.variableName) return;
        const freq = v.reportingFrequency || 'Hourly';
        idf.push(`Output:Variable,`);
        idf.push(`  ${v.key},                 !- Key Value`);
        idf.push(`  ${v.variableName},        !- Variable Name`);
        idf.push(`  ${freq};                  !- Reporting Frequency`);
        idf.push('');
    });
}

/**
 * Try to infer a reasonable location from project metadata.
 */
function isValidCustomLocation(loc) {
    if (!loc) return false;
    const { latitude, longitude, timeZone, elevation } = loc;
    if (!Number.isFinite(latitude) || latitude < -90 || latitude > 90) return false;
    if (!Number.isFinite(longitude) || longitude < -180 || longitude > 180) return false;
    if (!Number.isFinite(timeZone) || timeZone < -12 || timeZone > 14) return false;
    if (!Number.isFinite(elevation)) return false;
    return true;
}

function inferLocationFromProject() {
    try {
        const meta = project?.metadata || project?.getMetadata?.();
        if (!meta) return null;
        if (meta.location) {
            return {
                name: meta.location.name || 'Site',
                latitude: meta.location.latitude,
                longitude: meta.location.longitude,
                timeZone: meta.location.timeZone,
                elevation: meta.location.elevation,
            };
        }
    } catch {
        return null;
    }
    return null;
}

function inferBuildingNameFromProject() {
    try {
        const meta = project?.metadata || project?.getMetadata?.();
        return meta?.name || meta?.projectName || null;
    } catch {
        return null;
    }
}

/**
 * Try to infer zones from project (conservative).
 */
function inferZonesFromProject() {
    try {
        if (Array.isArray(project?.zones)) {
            return project.zones.map((z, i) => ({
                name: z.name || `Zone_${i + 1}`,
                x: z.xOrigin || 0,
                y: z.yOrigin || 0,
                z: z.zOrigin || 0,
                multiplier: z.multiplier || 1,
            }));
        }
        if (typeof project?.getZones === 'function') {
            const zones = project.getZones();
            if (Array.isArray(zones)) {
                return zones.map((z, i) => ({
                    name: z.name || `Zone_${i + 1}`,
                    x: z.xOrigin || 0,
                    y: z.yOrigin || 0,
                    z: z.zOrigin || 0,
                    multiplier: z.multiplier || 1,
                }));
            }
        }
    } catch {
        return [];
    }
    return [];
}

function sanitize(name) {
    if (!name) return 'Unnamed';
    return String(name).replace(/[;,]/g, '_').trim();
}
